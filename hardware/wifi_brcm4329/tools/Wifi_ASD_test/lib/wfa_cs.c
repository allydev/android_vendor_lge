/****************************************************************************
*  (c) Copyright 2007 Wi-Fi Alliance.  All Rights Reserved
*
*
*  LICENSE
*
*  License is granted only to Wi-Fi Alliance members and designated
*  contractors ($B!H(BAuthorized Licensees$B!I(B)..AN  Authorized Licensees are granted
*  the non-exclusive, worldwide, limited right to use, copy, import, export
*  and distribute this software:
*  (i) solely for noncommercial applications and solely for testing Wi-Fi
*  equipment; and
*  (ii) solely for the purpose of embedding the software into Authorized
*  Licensee$B!G(Bs proprietary equipment and software products for distribution to
*  its customers utipnder a license with at least the same restrictions as
*  contained in this License, including, without limitation, the disclaimer of
*  warranty and limitation of liability, below..AN  The distribution rights
*  granted in clause
*  (ii), above, include distribution to third party companies who will
*  redistribute the Authorized Licensee$B!G(Bs product to their customers with or
*  without such third party$B!G(Bs private label. Other than expressly granted
*  herein, this License is not transferable or sublicensable, and it does not
*  extend to and may not be used with non-Wi-Fi applications..AN  Wi-Fi Alliance
*  reserves all rights not expressly granted herein..AN
*.AN
*  Except as specifically set forth above, commercial derivative works of
*  this software or applications that use the Wi-Fi scripts generated by this
*  software are NOT AUTHORIZED without specific prior written permission from
*  Wi-Fi Alliance.
*.AN
*  Non-Commercial derivative works of this software for internal use are
*  authorized and are limited by the same restrictions; provided, however,
*  that the Authorized Licensee shall provide Wi-Fi Alliance with a copy of
*  such derivative works under a perpetual, payment-free license to use,
*  modify, and distribute such derivative works for purposes of testing Wi-Fi
*  equipment.
*.AN
*  Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
*  or promote products that are derived from or that use this software without
*  specific prior written permission from Wi-Fi Alliance.
*
*  THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESS OR
*  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
*  OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A.AN PARTICULAR PURPOSE,
*  ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
*  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
*  (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE
*  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
*  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
*  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF
*  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
*   File: wfa_cs.c -- configuration and setup
*   This file contains all implementation for the dut setup and control
*   functions, such as network interfaces, ip address and wireless specific
*   setup with its supplicant.
*
*   The current implementation is to show how these functions
*   should be defined in order to support the Agent Control/Test Manager
*   control commands. To simplify the current work and avoid any GPL licenses,
*   the functions mostly invoke shell commands by calling linux system call,
*   system("<commands>").
*
*   It depends on the differnt device and platform, vendors can choice their
*   own ways to interact its systems, supplicants and process these commands
*   such as using the native APIs.
*
*   Revision History:
*        2006/03/10  -- initially created by qhu
*        2006/06/01  -- BETA Release by qhu
*        2006/06/13  -- 00.02 Release by qhu
*        2006/06/30  -- 00.10 Release by qhu
*        2006/07/10  -- 01.00 Release by qhu
*        2006/09/01  -- 01.05 Release by qhu
*        2006/10/26  -- 01.06 Released by qhu
*                       replace hardcoded buf size with macro
*        2006/12/02  -- bugs: 1. fixes incorrect order of getipconfig.sh
*                                input parameters reported by p.schwann
*                             2. will add a new network for wap_cli command
*                                in case the network id 0 not present,
*                                recommended by c.benson
*                                the solution is to reimplement with calling
*                                native C API
*        2007/01/11  -- 01.10 released by qhu
*        2007/02/15  -- WMM Extension Beta released by qhu, mkaroshi
*        2007/03/18  -- add file close statements
*        2007/03/21  -- rename the file to avoid the confusion.
*        2007/03/30  -- 01.40 WPA2 and Official WMM Beta Release by qhu
*        2007/04/20  -- 02.00 WPA2 and Official WMM Release by qhu
*        2007/08/15 --  02.10 WMM-Power Save release by qhu
*        2007/10/10 --  02.20 Voice SOHO beta -- qhu
*        2007/11/07 --  02.30 Voice HSO -- qhu
*
*/
#ifndef WIN32
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <linux/types.h>
#include <linux/socket.h>
#include <poll.h>
#else
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <iphlpapi.h>
#endif

#include "wfa_debug.h"
#include "wfa_ver.h"
#include "wfa_main.h"
#include "wfa_types.h"
#include "wfa_ca.h"
#include "wfa_tlv.h"
#include "wfa_sock.h"
#include "wfa_tg.h"
#include "wfa_cmds.h"
#include "wfa_rsp.h"
#include "wfa_miscs.h"
extern char* rwl_client_path;
#define CERTIFICATES_PATH    "/etc/wpa_supplicant"

/* Some device may only support UDP ECHO, activate this line */
//#define WFA_PING_UDP_ECHO_ONLY 1

extern unsigned short wfa_defined_debug;
extern int rwl_wifi_flag;

/* Start --> Modified as per BRCM 1.3 ASD */

/* error code */
#define BCM_OK			0
#define BCM_BAD			1

#define BCM_SSID_LEN_MAX	32
#define BCM_SSID_MAX		32

/* defines for BSS types */
#define BCM_BSS_INVALID		0
#define	BCM_BSS_INDEPENDENT	1
#define BCM_BSS_INFRA		3
#define	BCM_BSS_AUTO		4

/* defines for WPA AITHENTICATION */
#define BCM_WPA_AUTH_DISABLED	0x0
#define BCM_WPA_AUTH_NONE	0x1
#define BCM_WPA_AUTH_8021X	0x2
#define BCM_WPA_AUTH_PSK	0x4
#define BCM_WPA2_AUTH_8021X	0x40
#define BCM_WPA2_AUTH_PSK	0x80

#define BCM_WEP_KEY_SIZE_MAX	32

#define BCM_PRI_KEY_BAD		(-1)

typedef struct bcmSsidObj
{
	char ssidStr[BCM_SSID_LEN_MAX];
	int bssType;
	int channel;
	int wsec;
	int auth; /* 802.11 authentication : default 0 for open. */
	int wpa_auth; /* WPA authentication: default 1 for WPA-NONE */
	int uapsd;
	char keys[4][BCM_WEP_KEY_SIZE_MAX]; /* wl addwep */
	int primary_key;
	BYTE passphrase[64]; /* wl set_pmk */
	int powerSave;
	/* UAPSD */
	int maxSPLength;
	int acBE;
	int acBK;
	int acVI;
	int acVO;
} bcmSsidObj_t;

typedef struct bcmSsidObjTbl
{
	bcmSsidObj_t ssidObj[BCM_SSID_MAX];
	uint addCnt;
	uint delCnt;
	uint entries;
} bcmSsidObjTbl_t;

bcmSsidObjTbl_t bsotbl;
int bcmSsidIsGood(char *ssidStr);
bcmSsidObj_t *bcmWfaSsidTblFreeEntry();
bcmSsidObj_t *bcmWfaSsidTblSsidFind(char *ssidStr);
bcmSsidObj_t *bcmWfaSsidObjTblAdd(char *ssidStr);
void bcmWfaSsidObjTblDel(char *ssidStr);
void bcmWfaSsidObjPrint(bcmSsidObj_t *bso);
void bcmWfaSsidObjTblPrint(void);

/* End --> Modified as per BRCM 1.3 ASD */

/* Since the two definitions are used all over the CA function */
char gCmdStr[WFA_CMD_STR_SZ];
dutCmdResponse_t gGenericResp;

/*
* agtCmdProcGetVersion(): response "ca_get_version" command to controller
*  input:  cmd --- not used
*          valLen -- not used
*  output: parms -- a buffer to store the version info response.
*/

int agtCmdProcGetVersion(int len, BYTE *parms, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t *getverResp = &gGenericResp;

	DPRINT_INFO(WFA_OUT, "entering agtCmdProcGetVersion ...\n");

	getverResp->status = STATUS_COMPLETE;
	strncpy(getverResp->cmdru.version, WFA_SYSTEM_VER, 8);

	wfaEncodeTLV(WFA_GET_VERSION_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)getverResp, respBuf);

	*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

	return TRUE;
}

/*
* wfaStaAssociate():
*    The function is to force the station wireless I/F to re/associate
*    with the AP.
*/
int wfaStaAssociate(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	int retVal = TRUE;
	dutCommand_t *assoc = (dutCommand_t *)caCmdBuf;
	dutCmdResponse_t *staAssocResp = &gGenericResp;
	/* Start: Modified as per BRCM 1.3 ASD */
	int imode; /* 0 for ibss, 1 for infrastructure */
	char ssidTarget[WFA_SSID_NAME_LEN];
	bcmSsidObj_t *bso;
	int idx;


	DPRINT_INFO(WFA_OUT, "entering wfaStaAssociate ...\n");
	/* use 'ifconfig' command to bring down the interface (linux specific) */

	memcpy(ssidTarget, assoc->cmdsu.ssid, WFA_SSID_NAME_LEN);
	bso = bcmWfaSsidTblSsidFind(ssidTarget);
	if (!bso) {
		if (!(bso = bcmWfaSsidObjTblAdd(ssidTarget))) {
			DPRINT_ERR(WFA_OUT, "bcmWfaSsidObjTblAdd(%s) failed\n", ssidTarget);
			retVal = FALSE;
			goto exit;
		}
		if (wfa_defined_debug & (WFA_DEBUG_ERR | WFA_DEBUG_INFO)) {
			bcmWfaSsidObjPrint(bso);
		}

	}
	imode = (bso->bssType == BCM_BSS_INDEPENDENT) ? 0 : 1;
	sprintf(gCmdStr, "%s disassoc", rwl_client_path);
	exec_process(gCmdStr);
	
	/* Run the commands in the batching mode in case of wifi transport*/
	if(rwl_wifi_flag) {
		asd_sleep(1);
		sprintf(gCmdStr, "%s seq_start", rwl_client_path);
		exec_process(gCmdStr);
	}
	

	asd_sleep(1);
	if ((!imode) && bso->channel){
		sprintf(gCmdStr, "%s channel %d", rwl_client_path, bso->channel);
		exec_process(gCmdStr);
	}

	sprintf(gCmdStr, "%s infra %d", rwl_client_path, imode);
	exec_process(gCmdStr);

	/*Execute the command wme_apsd_sta only if the driver is down*/
	sprintf(gCmdStr, "%s wme_apsd_sta %d %d %d %d %d", rwl_client_path, 
	bso->maxSPLength, bso->acBE, bso->acBK, bso->acVI, bso->acVO);
	exec_process(gCmdStr);

	asd_sleep(3);
	sprintf(gCmdStr, "%s up", rwl_client_path);
	exec_process(gCmdStr);
	
	if(rwl_wifi_flag) {
		sprintf(gCmdStr, "%s seq_stop", rwl_client_path);
		exec_process(gCmdStr);

	}

	sprintf(gCmdStr, "%s ssid %s", rwl_client_path, ssidTarget);
	exec_process(gCmdStr);

	asd_sleep(2);
	/* handle WEP keys */
	for(idx = 0; idx < 4; idx++) {
		if(bso->keys[idx][0] != '\0') {
			sprintf(gCmdStr, "%s addwep %d %s", rwl_client_path, idx, bso->keys[idx]);
		} else {
			sprintf(gCmdStr, "%s rmwep %d", rwl_client_path, idx);
		}
		exec_process(gCmdStr);
	}

	/* set primary key */
	if(bso->primary_key != BCM_PRI_KEY_BAD) {
		sprintf(gCmdStr, "%s primary_key %d", rwl_client_path, bso->primary_key);
		exec_process(gCmdStr);
	}

	/* security */
	sprintf(gCmdStr, "%s wsec %d", rwl_client_path, bso->wsec);
	exec_process(gCmdStr);

	if(bso->passphrase[0] != '\0') {
		sprintf(gCmdStr, "%s set_pmk %s", rwl_client_path, bso->passphrase);
		exec_process(gCmdStr);
	}
	
	if(bso->wpa_auth == BCM_WPA_AUTH_PSK) {
		sprintf(gCmdStr, "%s sup_wpa 1", rwl_client_path );
		exec_process(gCmdStr);	
	} else if(bso->wpa_auth == BCM_WPA2_AUTH_PSK) {
		sprintf(gCmdStr, "%s sup_wpa 2", rwl_client_path );
		exec_process(gCmdStr);	
	}

	sprintf(gCmdStr, "%s auth %d", rwl_client_path, bso->auth);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "%s wpa_auth %d", rwl_client_path, bso->wpa_auth);
	exec_process(gCmdStr);

	/*
	* Then report back to control PC for completion.
	* This does not have failed/error status. The result only tells
	* a completion.
	*/
exit:
	/* End: Modified as per BRCM 1.3 ASD   */

	/*
	* Then report back to control PC for completion.
	* This does not have failed/error status. The result only tells
	* a completion.
	*/
	staAssocResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, 4, (BYTE *)staAssocResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;

	return retVal;  /* Modified as per BRCM 1.3 ASD   */
}


/*
* wfaStaIsConnected():
*    The function is to check whether the station's wireless I/F has
*    already connected to an AP.
*/

int wfaStaIsConnected(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
#ifndef WIN32
	/* Removed as per BRCM 1.3 ASD */
	FILE *tmpfd;
#endif
	dutCmdResponse_t *staConnectResp = &gGenericResp;

	DPRINT_INFO(WFA_OUT, "Entering isConnected ...\n");

	/*
	* use 'wpa_cli' command to check the interface status
	* none, scanning or complete (wpa_supplicant specific)
	*/


	/* Start: Added as per BRCM 1.3 ASD */
	/* Associated gets long response */
#ifndef WIN32
	sprintf(gCmdStr, "%s assoc | wc -l", rwl_client_path);
	DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
	if ((tmpfd = popen(gCmdStr, "r")) == NULL)
	{
		staConnectResp->status = STATUS_ERROR;
		printf("wc -l failed\n");
		wfaEncodeTLV(WFA_STA_IS_CONNECTED_RESP_TLV, 4, (BYTE *)staConnectResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;

		DPRINT_ERR(WFA_ERR, "assoc wc -l open failed\n");
		return FALSE;
	}

	fgets(gCmdStr, sizeof(gCmdStr), tmpfd);
	pclose(tmpfd);
	/* Short response means not associated */
	if (atoi(gCmdStr) <= 2)
		staConnectResp->cmdru.connected = 0;
	else
		staConnectResp->cmdru.connected = 1;
	/* End: Added as per BRCM 1.3 ASD */
#endif

	/*
	* Report back the status: Complete or Failed.
	*/
	staConnectResp->status = STATUS_COMPLETE;

	wfaEncodeTLV(WFA_STA_IS_CONNECTED_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)staConnectResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

	return TRUE;
}


/*
* wfaStaGetIpConfig():
* This function is to retriev the ip info including
*     1. dhcp enable
*     2. ip address
*     3. mask
*     4. primary-dns
*     5. secondary-dns
*
*     The current implementation is to use a script to find these information
*     and store them in a file.
*/

int wfaStaGetIpConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	int   i = 0;
#ifdef WIN32
	int slen;
	DWORD dwStatus;
	IP_ADAPTER_INFO AdapterInfo[16];	// Allocate information for up to 16 NICs
	PIP_ADAPTER_INFO pAdapterInfo;
	DWORD dwBufLen = sizeof(AdapterInfo);	// Save the memory size of buffer
#endif

	dutCommand_t *getIpConf = (dutCommand_t *)caCmdBuf;
	dutCmdResponse_t *ipconfigResp = &gGenericResp;
	char *ifname = getIpConf->intf;
	caStaGetIpConfigResp_t *ifinfo = &ipconfigResp->cmdru.getIfconfig;
#ifndef WIN32 
	FILE *shell_fpt;
	char string[256];
#endif

#ifndef WIN32
	DPRINT_INFO(WFA_OUT,"Entering staGetIpConfig...\n");
	/* Start: Modified as per BRCM 1.3 ASD */
	/* Dhcp */
	sprintf(gCmdStr,"ps ax | grep -v grep | grep dhcli | wc -l");
	strcat(gCmdStr,">/tmp/temp.txt 2>&1");

	system(gCmdStr);

	shell_fpt = fopen("/tmp/temp.txt", "rb");
	fread(gCmdStr, sizeof(char), 20, shell_fpt);
	fclose(shell_fpt);

	remove("/tmp/temp.txt");
	if (atoi(string) >= 1)
		ifinfo->isDhcp = 1;
	else
		ifinfo->isDhcp = 0;
	/* ipaddr */
	sprintf(gCmdStr, "/sbin/ifconfig %s | grep 'inet addr' |  cut -d: -f2 | cut -d' ' -f1", ifname);
	DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
	strcat(gCmdStr,">/tmp/temp.txt 2>&1");

	system(gCmdStr);

	shell_fpt = fopen("/tmp/temp.txt", "rb");
	ifinfo->ipaddr[0] = 0;
	fread(ifinfo->ipaddr, sizeof(char), 20, shell_fpt);
	ifinfo->ipaddr[strlen(ifinfo->ipaddr) - 1] = 0; /* Purge newline */
	if(ifinfo->ipaddr[0] == 0)
		strncpy(ifinfo->ipaddr, "none", 15);
	fclose(shell_fpt);

	remove("/tmp/temp.txt");
	/* mask */
	sprintf(gCmdStr, "/sbin/ifconfig %s | grep 'inet addr' |  cut -d: -f4", ifname);
	DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
	strcat(gCmdStr,">/tmp/temp.txt 2>&1");

	system(gCmdStr);

	shell_fpt = fopen("/tmp/temp.txt", "rb");
	ifinfo->mask[0] = 0;
	fread(ifinfo->mask, sizeof(char), 20, shell_fpt);
	ifinfo->mask[strlen(ifinfo->mask) - 1] = 0; /* Purge newline */
	if(ifinfo->mask[0] == 0)
		strcpy(ifinfo->mask, "none");
	fclose(shell_fpt);

	remove("/tmp/temp.txt");
	/* dns */
	sprintf(gCmdStr, "cat /etc/resolv.conf | grep nameserver | awk '{print $2}'");
	DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
	strcat(gCmdStr,">/tmp/temp.txt 2>&1");

	system(gCmdStr);

	shell_fpt = fopen("/tmp/temp.txt", "rb");
	for (i = 0; i < WFA_MAX_DNS_NUM; i++){
		fread(ifinfo->mask, sizeof(char), 20, shell_fpt);
		if (ifinfo->dns[i][0])
			ifinfo->dns[i][strlen(ifinfo->dns[i]) - 1] = 0; /* Purge newline */
		else
			strcpy(ifinfo->dns[i], "NOTDEF");
	}

	fclose(shell_fpt);

	remove("/tmp/temp.txt");
	/* End: Modified as per BRCM 1.3 ASD */

#else
	/* The eth1 interface name in WinCE is BCMSDDHD1 and 
	* the eth0 interface name is VMINI1. The command that comes in from Linux CA
	* will send the eth0 or eth1 interface, which is then translated to WinCE 
	* specific interface name to get the Adapters information*/
	if(!strcmp(getIpConf->intf, "eth1")) {
		strcpy(getIpConf->intf , "BCMSDDHD1");
	} else if(!strcmp(getIpConf->intf, "eth0"))	{
		strcpy(getIpConf->intf , "VMINI1");
	} 
	/* Get the network interface information */
	dwStatus = GetAdaptersInfo(// Call GetAdapterInfo
		AdapterInfo,// [out] buffer to receive data
		&dwBufLen);// [in] size of receive data buffer

	pAdapterInfo= AdapterInfo;// Contains pointer to current adapter info

	while(pAdapterInfo){
		if(strcmp(pAdapterInfo->AdapterName, getIpConf->intf)==0){
			/*Check if DHCP Enabled*/
			if(pAdapterInfo->DhcpEnabled)
				ifinfo->isDhcp = 1;
			else
				ifinfo->isDhcp = 0;

			/*IP Address */
			strcpy(ifinfo->ipaddr, pAdapterInfo->IpAddressList.IpAddress.String);
			ifinfo->ipaddr[15]='\0';

			/*Subnet mask*/
			strcpy(ifinfo->mask,pAdapterInfo->IpAddressList.IpMask.String);
			slen = strlen(ifinfo->mask);
			ifinfo->mask[slen+1] = '\0';

			/*Primary DNS*/
			strcpy(ifinfo->dns[0], pAdapterInfo->PrimaryWinsServer.IpAddress.String);
			slen = strlen(ifinfo->dns[0]);

			/*Secondary DNS*/
			strcpy(ifinfo->dns[1], pAdapterInfo->SecondaryWinsServer.IpAddress.String);
			slen = strlen(ifinfo->dns[1]);
		}
		pAdapterInfo = pAdapterInfo->Next;
	}
#endif
	/*
	* Report back the results
	*/
	ipconfigResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)ipconfigResp, respBuf);

	*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
	DPRINT_INFO(WFA_OUT, "%i %i %s %s %s %s %i\n", ipconfigResp->status,
		ifinfo->isDhcp, ifinfo->ipaddr, ifinfo->mask,
		ifinfo->dns[0], ifinfo->dns[1], *respLen);
	return TRUE;
}

/*
* wfaStaSetIpConfig():
*   The function is to set the ip configuration to a wireless I/F.
*   1. IP address
*   2. Mac address
*   3. default gateway
*   4. dns nameserver (pri and sec).
*
* Set the IP address and the mask value only if the the DHCP(ipconfig->isDhcp) 
* is disabled. Otherwise enable the DHCP for the network interface.
*/
int wfaStaSetIpConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCommand_t *setIpConf = (dutCommand_t *)caCmdBuf;
	caStaSetIpConfig_t *ipconfig = &setIpConf->cmdsu.ipconfig;
	dutCmdResponse_t *staSetIpResp = &gGenericResp;
#ifdef WIN32
	DWORD Index;
	IP_ADAPTER_INFO AdapterInfo[16];	// Allocate information for up to 16 NICs
	DWORD dwStatus;
	DWORD dwBufLen = sizeof(AdapterInfo);		// Save the memory size of buffer
	PIP_ADAPTER_INFO pAdapterInfo;
#endif

	DPRINT_INFO(WFA_OUT, "entering wfaStaSetIpConfig ...\n");
#ifndef WIN32
	DPRINT_INFO(WFA_OUT, "interface = %s, ipaddr = %s, dhcp = %d\r\n",ipconfig->intf,ipconfig->ipaddr,ipconfig->isDhcp);
	/* Start: Modified as per BRCM 1.3 ASD */
	if(!ipconfig->isDhcp)
	{
		if (!strlen(ipconfig->intf) || !strlen(ipconfig->ipaddr) || !strlen(ipconfig->mask))
		{
			staSetIpResp->status = STATUS_ERROR;
			wfaEncodeTLV(WFA_STA_SET_IP_CONFIG_RESP_TLV, 4, (BYTE *)staSetIpResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;
			return TRUE; /* changed to be FALSE? */
		}
		sprintf(gCmdStr, "/sbin/ifconfig %s %s ", ipconfig->intf, ipconfig->ipaddr);
		if (strlen(ipconfig->mask))
			sprintf(&gCmdStr[strlen(gCmdStr)], "netmask %s ", ipconfig->mask);
		exec_process(gCmdStr);
		DPRINT_INFO(WFA_OUT, "%s\n", "doing ifconfig");
		/* End: Modified as per BRCM 1.3 ASD */

		/* use command 'route add' to set set gatewway (linux specific) */
		if(ipconfig->defGateway[0] != '\0')
		{
			sprintf(gCmdStr, "/sbin/route add default gw %s > /dev/null 2>&1", ipconfig->defGateway);
			exec_process(gCmdStr);
			DPRINT_INFO(WFA_OUT, "%s\n", "doing route add");
		}

		/* set dns (linux specific) */

		/* Start: Modified as per BRCM 1.3 ASD */
		if (ipconfig->pri_dns[0])
		{
			/* set dns (linux specific) */
			sprintf(gCmdStr, "cp /etc/resolv.conf /tmp/resolv.conf.bk");
			exec_process(gCmdStr);
			sprintf(gCmdStr, "echo nameserv %s > /etc/resolv.conf", ipconfig->pri_dns);
			exec_process(gCmdStr);
			sprintf(gCmdStr, "echo nameserv %s >> /etc/resolv.conf", ipconfig->sec_dns);
			exec_process(gCmdStr);
		}
	}
	else
	{
		/* dhcp is enabled */
		sprintf(gCmdStr, "killall -9 dhclient");
		exec_process(gCmdStr);
		sprintf(gCmdStr, "dhclient %s",ipconfig->intf);
		exec_process(gCmdStr);
	}
	/* End: Modified as per BRCM 1.3 ASD */
#else
	/*Set the IP address only if the DHCP is 0. otherwise run the DHCP*/
	if(!ipconfig->isDhcp)
	{
		dwStatus = GetAdaptersInfo(// Call GetAdapterInfo
			AdapterInfo,// [out] buffer to receive data
			&dwBufLen);// [in] size of receive data buffer

		pAdapterInfo = AdapterInfo;
		while(pAdapterInfo){
			if(strcmp(pAdapterInfo->AdapterName, ipconfig->intf) == 0)
			{
				Index = pAdapterInfo->Index;
			}
			pAdapterInfo =pAdapterInfo->Next;
		}

		IPProperties(ipconfig, &Index );
	}
	else {
		ResetIP(ipconfig);
	}
#endif

	/*
	* report status
	*/
	staSetIpResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_IP_CONFIG_RESP_TLV, 4, (BYTE *)staSetIpResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;

	return TRUE;
}

/*
* wfaStaVerifyIpConnection():
* The function is to verify if the station has IP connection with an AP by
* send ICMP/pings to the AP.
*/

int wfaStaVerifyIpConnection(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCommand_t *verip = (dutCommand_t *)caCmdBuf;
	dutCmdResponse_t *verifyIpResp = &gGenericResp;


#ifdef WIN32
	char cmdStr[WFA_CMD_STR_SZ];
	char tempip[30];
	wchar_t Args1[WFA_BUFF_256];
	unsigned int  position;
	FILE *tmpfile;
#else
	char *tempip;
	FILE *shell_fpt;
#endif

#ifndef WFA_PING_UDP_ECHO_ONLY

	DPRINT_INFO(WFA_OUT, "Entering wfaStaVerifyIpConnection ...\n");
#ifndef WIN32 
	tempip = (char*)malloc(30);
#endif
	/* set timeout value in case not set */
	if(verip->cmdsu.verifyIp.timeout <= 0)
	{
		verip->cmdsu.verifyIp.timeout = 10;
	}

	if (strlen(verip->cmdsu.verifyIp.dipaddr) == 0 )
	{
		verifyIpResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, 4, (BYTE *)&verifyIpResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;
		DPRINT_ERR(WFA_ERR, "Could not execute %s\n", gCmdStr);
		return FALSE;
	}

	strcpy(tempip,verip->cmdsu.verifyIp.dipaddr);

	strtok(tempip,". ");
	strtok(tempip,". ");
	strtok(tempip,". ");
	strtok(tempip,". ");

	if( atoi(tempip) >= 255 )
	{
		verifyIpResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, 4, (BYTE *)&verifyIpResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;
		return TRUE;
	}

#ifndef WIN32
	/* Start: Modified as per BRCM 1.3 ASD */
	/* execute the ping command  and pipe the result to a tmp file */
	sprintf(gCmdStr, "/bin/ping -c 3 -q %s >> /tmp/pingout.txt", verip->cmdsu.verifyIp.dipaddr);	
	exec_process(gCmdStr);

	asd_sleep(1);
	verifyIpResp->status = STATUS_COMPLETE;
	sprintf(gCmdStr, "cat /tmp/pingout.txt | grep transmitted | awk '{print $4}'");
	strcat(gCmdStr,">/tmp/temp.txt 2>&1");

	if (system(gCmdStr) < 0) {
		DPRINT_ERR(WFA_ERR, "\n Not able to execute verify ip cmd\n");
		verifyIpResp->cmdru.connected = 0;
	} 


	shell_fpt = fopen("/tmp/temp.txt", "rb");

	if (shell_fpt == NULL) {
		DPRINT_ERR(WFA_ERR, "\nShell Cmd:File open error\n");
		verifyIpResp->cmdru.connected = 0;
	}

	fread(gCmdStr, sizeof(char), 20, shell_fpt);
	fclose(shell_fpt);

	remove("/tmp/temp.txt");
	remove("/tmp/pingout.txt");
	if(atoi(gCmdStr) == 0)
		verifyIpResp->cmdru.connected = 0;
	else
		verifyIpResp->cmdru.connected = 1;

	printf("\ngCmdStr is:%s\n", gCmdStr);
#ifdef DEBUG
	DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
#endif
	/* End: Modified as per BRCM 1.3 ASD */
#else
	sprintf(cmdStr, "ping %s -n 3 -w %u", verip->cmdsu.verifyIp.dipaddr, verip->cmdsu.verifyIp.timeout);

	mbstowcs(Args1, cmdStr, strlen(cmdStr));
	asd_Config(cmdStr, ">temp\\RWL\\pingout.txt");
	tmpfile = fopen("temp\\RWL\\pingout.txt", "r+");
	if(tmpfile == NULL)
	{
		verifyIpResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, 4, (BYTE *)verifyIpResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;

		DPRINT_ERR(WFA_ERR, "file open failed\n");
		return FALSE;
	}

	verifyIpResp->status = STATUS_COMPLETE;
	if (FileSearch(tmpfile, L"PING: transmit failed", &position) == -1){
		verifyIpResp->cmdru.connected = 1;
	} else{
		verifyIpResp->cmdru.connected = 0;
	}

	fclose(tmpfile);
#endif

#else
	int btSockfd;
	struct pollfd fds[2];
	int timeout = 2000;
	char anyBuf[64];
	struct sockaddr_in toAddr;
	int done = 1, cnt = 0, ret, nbytes;

	verifyIpResp->status = STATUS_COMPLETE;
	verifyIpResp->cmdru.connected = 0;

	btSockfd = wfaCreateUDPSock("127.0.0.1", WFA_UDP_ECHO_PORT);

	if(btSockfd == -1)
	{
		verifyIpResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, 4, (BYTE *)verifyIpResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;
		return FALSE;;
	}

	toAddr.sin_family = AF_INET;
	toAddr.sin_addr.s_addr = inet_addr(verip->cmdsu.verifyIp.dipaddr);
	toAddr.sin_port = htons(WFA_UDP_ECHO_PORT);

	while(done)
	{
		wfaTrafficSendTo(btSockfd, (char *)anyBuf, 64, (struct sockaddr *)&toAddr);
		cnt++;

		fds[0].fd = btSockfd;
		fds[0].events = POLLIN | POLLOUT;

		ret = poll(fds, 1, timeout);
		switch(ret)
		{
		case 0:
			/* it is time out, count a packet lost*/
			break;
		case -1:
			/* it is an error */
		default:
			{
				switch(fds[0].revents)
				{
				case POLLIN:
				case POLLPRI:
				case POLLOUT:
					nbytes = wfaTrafficRecv(btSockfd, (char *)anyBuf, (struct sockaddr *)&toAddr);
					if(nbytes != 0)
						verifyIpResp->cmdru.connected = 1;
					done = 0;
					break;
				default:
					/* errors but not care */
					;
				}
			}
		}
		if(cnt == 3)
		{
			done = 0;
		}
	}
#endif

	wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)verifyIpResp, respBuf);

	*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

	return TRUE;
}


/*
* wfaStaGetMacAddress()
*    This function is to retrieve the MAC address of a wireless I/F.
*/

int wfaStaGetMacAddress(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t *getmacResp = &gGenericResp;

#ifndef WIN32
	FILE *tmpfd;
#endif

	DPRINT_INFO(WFA_OUT, "Entering wfaStaGetMacAddress ...\n");

	/* Start: Modifed as per BRCM 1.3 ASD*/
#ifndef WIN32
	/* Modified on 28/12/07 after getting wl dump error in 4325*/
	//sprintf(gCmdStr, "ifconfig %s|grep HWaddr|cut -f3 -dr", ifname);
	sprintf(gCmdStr, "%s cur_etheraddr", rwl_client_path);
	DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
	if ((tmpfd = popen(gCmdStr, "r")) == NULL)
	{
		getmacResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_GET_MAC_ADDRESS_RESP_TLV, 4, (BYTE *)getmacResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;
		DPRINT_ERR(WFA_ERR, "failed to get mac address :(\n");
		return FALSE;
	}
	fgets(gCmdStr, 15, tmpfd);
	/*End:Modified on 28/12/07 after getting wl dump error in 4325 */
	fgets(getmacResp->cmdru.mac, sizeof(getmacResp->cmdru.mac), tmpfd);
	getmacResp->cmdru.mac[strlen(getmacResp->cmdru.mac) - 1] = 0;		/* Get rid of NL */
	printf("get_mac_addr: returning mac :%s:\n", getmacResp->cmdru.mac);
	pclose (tmpfd);


#endif
	getmacResp->status = STATUS_COMPLETE;

	wfaEncodeTLV(WFA_STA_GET_MAC_ADDRESS_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)getmacResp, respBuf);

	*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

	return TRUE;
}


/*
* wfaStaGetStats():
* The function is to retrieve the statistics of the I/F's layer 2 txFrames,
* rxFrames, txMulticast, rxMulticast, fcsErrors/crc, and txRetries.
* Currently there is not definition how to use these info.
*/

int wfaStaGetStats(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t *statsResp = &gGenericResp;
#ifndef WIN32
	FILE *fd; /* Added as per BRCM 1.3 ASD */
#endif
	caStaGetStatsResp_t *castatsResp = &statsResp->cmdru.ifStats; /* Added as per BRCM 1.3 ASD */

#ifndef WIN32
	DPRINT_INFO(WFA_OUT, "Entering wfaStaGetStats ...\n");
	/* Start: Modified as per BRCM 1.3 ASD */
	sprintf(gCmdStr, "%s counters | grep txframe | awk '{print $2,\"\\n\",$10}'", rwl_client_path);
	DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
	/* wl dump replaced with wl counters to get statistics */
	if ((fd = popen(gCmdStr, "r")) == NULL){
		DPRINT_ERR(WFA_ERR, "Couldn't get txframe stats\n");
		goto wfaStaGetStats_error;
	} else {
		fgets(gCmdStr, sizeof(gCmdStr), fd);	/* line 1: tx frame */
		castatsResp->txFrames =  atoi(gCmdStr);
		fgets(gCmdStr, sizeof(gCmdStr), fd);	/* line 2: rx frame */
		castatsResp->rxFrames =  atoi(gCmdStr);
		pclose(fd);
	}

	sprintf(gCmdStr, "%s counters | grep d11_txmulti | awk '{print $4,\"\\n\",$8}' ", rwl_client_path);
	DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
	if ((fd = popen(gCmdStr,"r")) == NULL){
		DPRINT_ERR(WFA_ERR, "Couldn't get d11_txmulti stats\n");
		goto wfaStaGetStats_error;
	} else {
		fgets(gCmdStr, sizeof(gCmdStr), fd);
		castatsResp->txMulticast = atoi(gCmdStr);
		fgets(gCmdStr, sizeof(gCmdStr), fd);
		castatsResp->txRetries = atoi(gCmdStr);
		pclose(fd);
	}
	sprintf(gCmdStr, "%s counters | grep d11_rxmulti | awk '{print $4}'", rwl_client_path);
	DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
	if ((fd = popen(gCmdStr ,"r")) == NULL){
		DPRINT_ERR(WFA_ERR, "Couldn't get rxMultiFrame stats\n");
		goto wfaStaGetStats_error;
	} else {
		fgets(gCmdStr, sizeof(gCmdStr), fd);
		castatsResp->rxMulticast = atoi(gCmdStr);
		pclose(fd);
	}

	sprintf(gCmdStr, "%s counters | grep rxbadfcs | awk '{print $8}'", rwl_client_path);
	DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
	if ((fd = popen(gCmdStr, "r")) == NULL){
		DPRINT_ERR(WFA_ERR, "Couldn't get rxbadfcs  stats\n");
		goto wfaStaGetStats_error;
	} else {
		fgets(gCmdStr, sizeof(gCmdStr), fd);
		castatsResp->fcsErrors = atoi(gCmdStr);
		pclose(fd);
	}
#endif
	/* End: Modified as per BRCM 1.3 ASD */

	statsResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_GET_STATS_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)statsResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
	return TRUE;

#ifndef WIN32
wfaStaGetStats_error:
	statsResp->status = STATUS_ERROR;
	wfaEncodeTLV(WFA_STA_GET_STATS_RESP_TLV, 4, (BYTE *)statsResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;
	return FALSE;
#endif
}

/*
* wfaSetEncryption():
*   The function is to set the wireless interface with WEP or none.
*   Input parameters:
*     1. I/F
*     2. ssid
*     3. encpType - wep or none
*     Optional:
*     4. key1
*     5. key2
*     6. key3
*     7. key4
*     8. activeKey Index
*/

int wfaSetEncryption(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
	dutCmdResponse_t *setEncrypResp = &gGenericResp;
	int idx; /* Modified as per BRCM 1.3 ASD */
	/* Start: Modified as per BRCM 1.3 ASD */
	int retVal = TRUE;
	bcmSsidObj_t *bso;
	char * ssidStr;

	DPRINT_INFO(WFA_OUT, "wfaSetEncryption()\n");

	/* Save the settings for when we need them */

	ssidStr = setEncryp->ssid;

	if (!(bso = bcmWfaSsidTblSsidFind(ssidStr))) {
		if (!(bso = bcmWfaSsidObjTblAdd(ssidStr))) {
			DPRINT_INFO(WFA_OUT, "bcmWfaSsidObjTblAdd(%s) failed.\n", ssidStr);
			retVal = FALSE;
			goto exit;
		}
	}

	/* set Key management to NONE (NO WPA) for plaintext or WEP */
	bso->wpa_auth = BCM_WPA_AUTH_DISABLED;

	for(idx = 0; idx < 4; idx++) {
		if(setEncryp->keys[idx][0] != '\0') {
			strcpy(bso->keys[idx], setEncryp->keys[idx]);
		} else {
			memset(bso->keys[idx],0,BCM_WEP_KEY_SIZE_MAX);
		}
	}

	if ((setEncryp->activeKeyIdx > 0) && (setEncryp->activeKeyIdx < 5)) {
		/* move the index range from (1 to 4) to (0 to 3) */
		bso->primary_key = setEncryp->activeKeyIdx - 1;
	}

	bso->wsec = (!setEncryp->encpType) ? 0 : 1;

	if (wfa_defined_debug & (WFA_DEBUG_ERR | WFA_DEBUG_INFO)) {
		bcmWfaSsidObjPrint(bso);
	}

exit:
	/* End: Modified as per BRCM 1.3 ASD */

	setEncrypResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;

	return retVal; /* Modified as per BRCM 1.3 ASD */
}


int wfaSetEncryption1(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
	dutCmdResponse_t *setEncrypResp = &gGenericResp;
	int idx;
	/* Start: Modified as per BRCM 1.3 ASD */
	int retVal = TRUE;
	bcmSsidObj_t *bso;
	char * ssidStr;

	DPRINT_INFO(WFA_OUT, "wfaSetEncryption1()\n");

	/* Save the settings for when we need them */

	ssidStr = setEncryp->ssid;
	/* SetSSID */
	if (!(bso = bcmWfaSsidTblSsidFind(ssidStr))) {
		if (!(bso = bcmWfaSsidObjTblAdd(ssidStr))) {
			DPRINT_INFO(WFA_OUT, "bcmWfaSsidObjTblAdd(%s) failed.\n", ssidStr);
			retVal = FALSE;
			goto exit;
		}
	}

	/* set Key management to NONE (NO WPA) for plaintext or WEP */
	bso->wpa_auth = BCM_WPA_AUTH_DISABLED;

	for(idx = 0; idx < 4; idx++) {
		if(setEncryp->keys[idx][0] != '\0') {
			strcpy(bso->keys[idx], setEncryp->keys[idx]);
		} else {
			memset(bso->keys[idx], 0, BCM_WEP_KEY_SIZE_MAX);
		}
	}

	if ((setEncryp->activeKeyIdx > 0) && (setEncryp->activeKeyIdx < 5)) {
		/* move the index range from (1 to 4) to (0 to 3) */
		bso->primary_key = setEncryp->activeKeyIdx - 1;
	}

	bso->wsec = (!setEncryp->encpType) ? 0 : 1;

	if (wfa_defined_debug & (WFA_DEBUG_ERR | WFA_DEBUG_INFO)) {
		bcmWfaSsidObjPrint(bso);
	}

exit:
	/* End: Modified as per BRCM 1.3 ASD */

	setEncrypResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;

	return retVal; /* Modified as per BRCM 1.3 ASD */
}


/*
* wfaStaSetEapTLS():
*   This is to set
*   1. ssid
*   2. encrypType - tkip or aes-ccmp
*   3. keyManagementType - wpa or wpa2
*   4. trustedRootCA
*   5. clientCertificate
*/
int wfaStaSetEapTLS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caStaSetEapTLS_t *setTLS = (caStaSetEapTLS_t *)caCmdBuf;
	char *ifname = setTLS->intf;
	dutCmdResponse_t *setEapTlsResp = &gGenericResp;

	DPRINT_INFO(WFA_OUT, "Entering wfaStaSetEapTLS ...\n");
#ifndef WIN32
	/*
	* need to store the trustedROOTCA and clientCertificate into a file first.
	*/
	sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
	exec_process(gCmdStr);

	/* ssid */
	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setTLS->ssid);
	exec_process(gCmdStr);

	/* key management */
	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
	exec_process(gCmdStr);

	/* protocol WPA */
	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 proto WPA", ifname);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap TLS", ifname);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ca_cert '\"%s\"'", ifname, setTLS->trustedRootCA);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"wifi-user@wifilabs.local\"'", ifname);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 private_key '\"%s/%s\"'", ifname, CERTIFICATES_PATH, setTLS->clientCertificate);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 private_key_passwd '\"wifi\"'", ifname);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
	exec_process(gCmdStr);
#endif

	setEapTlsResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_EAPTLS_RESP_TLV, 4, (BYTE *)setEapTlsResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;
	return TRUE;
}

/*
* The function is to set
*   1. ssid
*   2. passPhrase
*   3. keyMangementType - wpa/wpa2
*   4. encrypType - tkip or aes-ccmp
*/

int wfaStaSetPSK(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caStaSetPSK_t *setPSK = (caStaSetPSK_t *)caCmdBuf;
	dutCmdResponse_t *setPskResp = &gGenericResp;

	/* Start: Modified as per BRCM 1.3 ASD */
	int retVal = TRUE;
	bcmSsidObj_t *bso;
	char *ssidStr;

	DPRINT_INFO(WFA_OUT, "wfaStaSetPSK()");

	ssidStr = setPSK->ssid;
	if (!(bso = bcmWfaSsidTblSsidFind(ssidStr))) {
		if (!(bso = bcmWfaSsidObjTblAdd(ssidStr))) {
			DPRINT_ERR(WFA_OUT, "bcmWfaSsidObjTblAdd(%s) failed.\n", ssidStr);
			retVal = FALSE;
			goto exit;
		}
	}

	if (!strcmp(setPSK->keyMgmtType, "wpa")) {
		bso->wpa_auth = BCM_WPA_AUTH_PSK; /* WPA-PSK/WPA-Personal */
	} else if (!strcmp(setPSK->keyMgmtType, "wpa2")) {
		bso->wpa_auth = BCM_WPA2_AUTH_PSK; /* WPA2-PSK/WPA2-Personal */
	} else {
		DPRINT_ERR(WFA_OUT, "invalid key_mgmt %s", setPSK->keyMgmtType);
		retVal = FALSE;
		goto exit;
	}

	DPRINT_INFO(WFA_OUT, "wpa_auth %d\n", bso->wpa_auth);

	if (setPSK->encpType == ENCRYPT_TKIP) {
		bso->wsec = 3;
	} else if (setPSK->encpType == ENCRYPT_AESCCMP) {
		bso->wsec = 7;
	} else {
		DPRINT_ERR(WFA_OUT, "invalid encpType %d", setPSK->encpType);
		goto exit;
	}
	DPRINT_INFO(WFA_OUT, "encpType %d wsec %d\n", setPSK->encpType, bso->wsec);


	strncpy((char *)bso->passphrase, (char *)setPSK->passphrase, 64);
	bso->auth = 0;

	if (wfa_defined_debug & (WFA_DEBUG_ERR | WFA_DEBUG_INFO)) {
		bcmWfaSsidObjPrint(bso);
	}

	retVal = TRUE;

exit:
	/* End: Modified as per BRCM 1.3 ASD */

	setPskResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setPskResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;

	return retVal; /*  Modified as per BRCM 1.3 ASD */
}


/*
* wfaStaGetInfo():
* Get vendor specific information in name/value pair by a wireless I/F.
*/
int wfaStaGetInfo(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t infoResp;
	dutCommand_t *getInfo = (dutCommand_t *)caCmdBuf;
	DPRINT_INFO(WFA_OUT, "Entering wfaStaGetInfo.....\n");
	/*
	* Normally this is called to retrieve the vendor information
	* from a interface, no implement yet
	*/
	sprintf(infoResp.cmdru.info, "interface,%s,vendor,Broadcom,cardtype,802.11a/b/g", getInfo->intf);
	infoResp.status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_GET_INFO_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

	return TRUE;
}

int wfaStaGetTestData(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	//    dutCmdResponse_t dataResp;
	//    dutCommand_t *testData = (dutCommand_t *)caCmdBuf;

	/*
	* This is to trasfer the test log (file) back to console
	* It has not decided to use in-band or out of band. Will be updated
	* in a new release soon.
	*/

	return TRUE;
}

/*
* wfaStaSetEapTTLS():
*   This is to set
*   1. ssid
*   2. username
*   3. passwd
*   4. encrypType - tkip or aes-ccmp
*   5. keyManagementType - wpa or wpa2
*   6. trustedRootCA
*/
int wfaStaSetEapTTLS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caStaSetEapTTLS_t *setTTLS = (caStaSetEapTTLS_t *)caCmdBuf;
	char *ifname = setTTLS->intf;
	dutCmdResponse_t *setEapTtlsResp = &gGenericResp;
#ifndef WIN32
	sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setTTLS->ssid);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setTTLS->username);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 password '\"%s\"'", ifname, setTTLS->passwd);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
	exec_process(gCmdStr);

	/* This may not need to set. if it is not set, default to take all */
	//   sprintf(cmdStr, "wpa_cli -i %s set_network 0 pairwise '\"%s\"", ifname, setTTLS->encrptype);
	//   exec_process(cmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap TTLS", ifname);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ca_cert '\"%s/%s\"'", ifname, CERTIFICATES_PATH, setTTLS->trustedRootCA);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 proto WPA", ifname);
	exec_process(gCmdStr);

	//   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 anonymous_identity '\"anonymous\"'", ifname);
	//   exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase2 '\"auth=MSCHAPV2\"'", ifname);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
	exec_process(gCmdStr);
#endif

	setEapTtlsResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_EAPTTLS_RESP_TLV, 4, (BYTE *)setEapTtlsResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;

	return TRUE;
}

/*
* wfaStaSetEapSIM():
*   This is to set
*   1. ssid
*   2. user name
*   3. passwd
*   4. encrypType - tkip or aes-ccmp
*   5. keyMangementType - wpa or wpa2
*/
int wfaStaSetEapSIM(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caStaSetEapSIM_t *setSIM = (caStaSetEapSIM_t *)caCmdBuf;
	char *ifname = setSIM->intf;
	dutCmdResponse_t *setEapSimResp = &gGenericResp;
#ifndef WIN32
	sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setSIM->ssid);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setSIM->username);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 pairwise '\"%s\"'", ifname, setSIM->encrptype);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap SIM", ifname);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 proto WPA", ifname);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
	exec_process(gCmdStr);
#endif

	setEapSimResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_EAPSIM_RESP_TLV, 4, (BYTE *)setEapSimResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;

	return TRUE;
}

/*
* wfaStaSetPEAP()
*   This is to set
*   1. ssid
*   2. user name
*   3. passwd
*   4. encryType - tkip or aes-ccmp
*   5. keyMgmtType - wpa or wpa2
*   6. trustedRootCA
*   7. innerEAP
*   8. peapVersion
*/
int wfaStaSetPEAP(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caStaSetEapPEAP_t *setPEAP = (caStaSetEapPEAP_t *)caCmdBuf;
	char *ifname = setPEAP->intf;
	dutCmdResponse_t *setPeapResp = &gGenericResp;
#ifndef WIN32
	sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setPEAP->ssid);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap PEAP", ifname);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 anonymous_identity '\"anonymous\"' ", ifname);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setPEAP->username);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 password '\"%s\"'", ifname, setPEAP->passwd);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ca_cert '\"%s/%s\"'", ifname, CERTIFICATES_PATH, setPEAP->trustedRootCA);
	exec_process(gCmdStr);

	/* if this not set, default to set support all */
	//sprintf(gCmdStr, "wpa_cli -i %s set_network 0 pairwise '\"%s\"'", ifname, setPEAP->encrptype);
	//exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase1 '\"peaplabel=%i\"'", ifname, setPEAP->peapVersion);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase2 '\"auth=%s\"'", ifname, setPEAP->innerEAP);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
	exec_process(gCmdStr);
#endif

	setPeapResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_PEAP_RESP_TLV, 4, (BYTE *)setPeapResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;

	return TRUE;
}

/*
* wfaStaSetUAPSD()
*    This is to set
*    1. maxSPLength - 0,1,2,or 4
*    2. acBE
*    3. acBK
*    4. acVI
*    5. acVO
*/
int wfaStaSetUAPSD(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caStaSetUAPSD_t *setUAPSD = (caStaSetUAPSD_t *)caCmdBuf;
	/* char *ifname = setUAPSD->intf; */ /* Removed as per BRCM 1.3 ASD */
	dutCmdResponse_t *setUAPSDResp = &gGenericResp;
	/* Start: Modified as per BRCM 1.3 ASD */
	int retVal = TRUE;
	bcmSsidObj_t *bso;
	char *ssidStr;

	DPRINT_INFO(WFA_OUT, "Entering StaSetUAPSD ...\n");
	DPRINT_INFO(WFA_OUT, "maxSPLength %d acBE %d acBK %d acVI %d acVO %d\n",
		setUAPSD->maxSPLength, setUAPSD->acBE, setUAPSD->acBK, setUAPSD->acVI, setUAPSD->acVO);

	ssidStr = setUAPSD->ssid;

	if (!(bso = bcmWfaSsidTblSsidFind(ssidStr))) {
		if (!(bso = bcmWfaSsidObjTblAdd(ssidStr))) {
			DPRINT_INFO(WFA_OUT, "bcmWfaSsidObjTblAdd(%s) failed.\n", ssidStr);
			retVal = FALSE;
			goto exit;
		}
	}

	bso->maxSPLength = setUAPSD->maxSPLength;
	bso->acBE = setUAPSD->acBE;
	bso->acBK = setUAPSD->acBK;
	bso->acVI = setUAPSD->acVI;
	bso->acVO = setUAPSD->acVO;

exit:
	/* End: Modified as per BRCM 1.3 ASD */

	setUAPSDResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_UAPSD_RESP_TLV, 4, (BYTE *)setUAPSDResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;

	return retVal; /* Modified as per BRCM 1.3 ASD */
}

int wfaDeviceGetInfo(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t *infoResp = &gGenericResp;
	/*a vendor can fill in the proper info or anything non-disclosure */
	caDeviceGetInfoResp_t dinfo = {"WFA Lab", "DemoUnit", WFA_SYSTEM_VER};
	/* Start: Modified as per BRCM 1.3 ASD */
#ifndef WIN32
	FILE *fd;
#endif

#ifndef WIN32
	sprintf(gCmdStr,"%s ver | awk '{print $7}'", rwl_client_path);
#ifdef DEBUG
	DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
#endif
	if ((fd = popen(gCmdStr, "r")) == NULL) {
		printf("Couldn't open either wl or awk\n");
		infoResp->status = STATUS_ERROR;
	} else {
		memset(&dinfo, 0, sizeof(dinfo));
		fgets(gCmdStr, sizeof(gCmdStr), fd);	/* Ignore first line */
		fgets(gCmdStr, sizeof(gCmdStr), fd);
		gCmdStr[strlen(gCmdStr) - 1] = 0;		/* Get rid of NL */
		pclose(fd);

		infoResp->status = STATUS_COMPLETE;
		sprintf(dinfo.vendor, "%.16s", "Broadcom");
		sprintf(dinfo.version, "%.16s", gCmdStr);
		sprintf(dinfo.model, "%.8s", "BRCM");

		DPRINT_INFO(WFA_OUT, "Entering wfaDeviceGetInfo ...\n");
		DPRINT_INFO(WFA_OUT, "status %i vendor %s model %s version %s\n", infoResp->status,
			dinfo.vendor,dinfo.model, dinfo.version);
		memcpy(&infoResp->cmdru.devInfo, &dinfo, sizeof(caDeviceGetInfoResp_t));
	}

#endif
	infoResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_DEVICE_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);

	*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
	/* End: Modified as per BRCM 1.3 ASD */

	return TRUE;

}

/*
* This funciton is to retrieve a list of interfaces and return
* the list back to Agent control.
*
*/
int wfaDeviceListIF(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t *infoResp = &gGenericResp;
	dutCommand_t *ifList = (dutCommand_t *)caCmdBuf;
	caDeviceListIFResp_t *ifListResp = &infoResp->cmdru.ifList;

	DPRINT_INFO(WFA_OUT, "Entering wfaDeviceListIF ...\n");

	switch(ifList->cmdsu.iftype)
	{
	case IF_80211:
		infoResp->status = STATUS_COMPLETE;
		ifListResp->iftype = IF_80211;
		/*In case of the WinCE the wireless interface is BCMSDDHD1*/
#ifndef WIN32
		strcpy(ifListResp->ifs[0], "eth1	");
#else
		strcpy(ifListResp->ifs[0], "BCMSDDHD1");
#endif
		strcpy(ifListResp->ifs[1], "NULL");
		strcpy(ifListResp->ifs[2], "NULL");
		break;

	case IF_ETH:
		infoResp->status = STATUS_COMPLETE;
		ifListResp->iftype = IF_ETH;
		/*In case of the WinCE the ethernet interface is VMINI1*/
#ifndef WIN32
		strcpy(ifListResp->ifs[1], "eth0	");
#else
		strcpy(ifListResp->ifs[1], "VMINI1");
#endif
		strcpy(ifListResp->ifs[1], "NULL");
		strcpy(ifListResp->ifs[2], "NULL");
		break;
	default:
		{
			infoResp->status = STATUS_ERROR;
			wfaEncodeTLV(WFA_DEVICE_LIST_IF_RESP_TLV, 4, (BYTE *)infoResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + 4;

			return TRUE;
		}
	}

	wfaEncodeTLV(WFA_DEVICE_LIST_IF_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

	return TRUE;
}

int wfaStaDebugSet(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	dutCmdResponse_t *debugResp = &gGenericResp;
	dutCommand_t *debugSet = (dutCommand_t *)caCmdBuf;

	DPRINT_INFO(WFA_OUT, "Entering wfaStaDebugSet ...\n");

	if(debugSet->cmdsu.dbg.state == 1) /* enable */
		wfa_defined_debug |= debugSet->cmdsu.dbg.level;
	else
		wfa_defined_debug = (~debugSet->cmdsu.dbg.level & wfa_defined_debug);

	debugResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)debugResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

	return TRUE;
}


/*
*   wfaStaGetBSSID():
*     This function is to retrieve BSSID of a specific wireless I/F.
*/
int wfaStaGetBSSID(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
#ifndef WIN32
	FILE *tmpfd;
#endif
	dutCmdResponse_t *bssidResp = &gGenericResp;

	DPRINT_INFO(WFA_OUT, "Entering wfaStaGetBSSID ...\n");

#ifndef WIN32
	/* Start: Modified for BRCM 1.3 ASD */
	/* Associated gets long response */
	sprintf(gCmdStr, "%s assoc | wc -l", rwl_client_path);
	DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
	if ((tmpfd = popen(gCmdStr, "r")) == NULL) {
		printf("wc -l failed\n");
		bssidResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_GET_BSSID_RESP_TLV, 4, (BYTE *)bssidResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;

	}
	fgets(gCmdStr, sizeof(gCmdStr), tmpfd);
	pclose(tmpfd);

	/* Short response means not associated */
	if (atoi(gCmdStr) <= 2) {
		strcpy(bssidResp->cmdru.bssid, "00:00:00:00:00:00");
	} else {
		sprintf(gCmdStr, "%s bssid", rwl_client_path);
		DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
		if ((tmpfd = popen(gCmdStr, "r")) == NULL){
			printf("bssid failed\n");
		}
		fgets(gCmdStr, sizeof(gCmdStr), tmpfd);
		pclose(tmpfd);
		gCmdStr[17] = 0;	/* Get rid of CR or NL */
		strcpy(bssidResp->cmdru.bssid, gCmdStr);
	}
#endif
	bssidResp->status = STATUS_COMPLETE;
	/* End Modified as per BRCM 1.3 ASD */
	wfaEncodeTLV(WFA_STA_GET_BSSID_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)bssidResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

	return TRUE;
}

/*
* wfaStaSetIBSS()
*    This is to set
*    1. ssid
*    2. channel
*    3. encrypType - none or wep
*    optional
*    4. key1
*    5. key2
*    6. key3
*    7. key4
*    8. activeIndex - 1, 2, 3, or 4
*/
int wfaStaSetIBSS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caStaSetIBSS_t *setIBSS = (caStaSetIBSS_t *)caCmdBuf;
	dutCmdResponse_t *setIbssResp = &gGenericResp;

	/* Start: Modified as per BRCM 1.3 ASD */
	int retVal = TRUE;
	bcmSsidObj_t *bso;
	int idx;
	char *ssidStr;

	DPRINT_INFO(WFA_OUT, "wfaStaSetIBSS()\n");

	/* Save the settings for when we need them */

	ssidStr = setIBSS->ssid;

	if (!(bso = bcmWfaSsidTblSsidFind(ssidStr))) {
		if (!(bso = bcmWfaSsidObjTblAdd(ssidStr))) {
			DPRINT_INFO(WFA_OUT, "bcmWfaSsidObjTblAdd(%s) failed.\n", ssidStr);
			retVal = FALSE;
			goto exit;
		}
	}

	bso->bssType = BCM_BSS_INDEPENDENT;

	if (setIBSS->channel) {
		bso->channel = setIBSS->channel;
	}

	bso->wsec = (!setIBSS->encpType) ? 0 : 1;

	for(idx = 0; idx < 4; idx++) {
		if(setIBSS->keys[idx][0] != '\0') {
			strcpy(bso->keys[idx], setIBSS->keys[idx]);
		} else {
			memset(bso->keys[idx],0, BCM_WEP_KEY_SIZE_MAX);
		}
	}

	if ((setIBSS->activeKeyIdx > 0) && (setIBSS->activeKeyIdx < 5)) {
		/* move the index range from (1 to 4) to (0 to 3) */
		bso->primary_key = setIBSS->activeKeyIdx - 1;
	}

	if (wfa_defined_debug & (WFA_DEBUG_ERR | WFA_DEBUG_INFO)) {
		bcmWfaSsidObjPrint(bso);
	}
exit:
	/* End: Modified as per BRCM 1.3 ASD */

	setIbssResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_IBSS_RESP_TLV, 4, (BYTE *)setIbssResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;

	return retVal; /* Modified as per BRCM 1.3 ASD */
}

/*
*  wfaSetMode():
*  The function is to set the wireless interface with a given mode (possible
*  adhoc)
*  Input parameters:
*    1. I/F
*    2. ssid
*    3. mode adhoc or managed
*    4. encType
*    5. channel
*    6. key(s)
*    7. active  key
*/
int wfaStaSetMode(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caStaSetMode_t *setmode = (caStaSetMode_t *)caCmdBuf;
	dutCmdResponse_t *SetModeResp = &gGenericResp;
	int i;
	bcmSsidObj_t *bso;
	char *ssidStr;
	int retVal = TRUE;

	DPRINT_INFO(WFA_OUT,"Entering wfaStaSetMode\r\n");

	ssidStr = setmode->ssid;
	if (!(bso = bcmWfaSsidTblSsidFind(ssidStr))) {
		if (!(bso = bcmWfaSsidObjTblAdd(ssidStr))) {
			DPRINT_INFO(WFA_OUT, "bcmWfaSsidObjTblAdd(%s) failed.\n", ssidStr);
			retVal = FALSE;
			goto exit;
		}
		else
		{
			//DPRINT_INFO(WFA_OUT, "bcmWfaSsidObjTblAdd added: (%s)\n", ssidStr);
		}
	}

	if (setmode->channel) {
		bso->channel = setmode->channel;
		/* Set the channel */
		sprintf(gCmdStr, "%s channel %d",rwl_client_path, setmode->channel);
		exec_process(gCmdStr);
	}

	/* destroy the interface */
	sprintf(gCmdStr, "%s disassoc", rwl_client_path);
	exec_process(gCmdStr);

	/* re-create the interface in the given mode */
	if(setmode->mode)
	{
		bso->bssType = BCM_BSS_INDEPENDENT;
		sprintf(gCmdStr, "%s infra %d", rwl_client_path, setmode->mode);
		exec_process(gCmdStr);
		sprintf(gCmdStr, "%s join %s imode ibss", rwl_client_path, setmode->ssid);
		exec_process(gCmdStr);
	}
	else
	{
		sprintf(gCmdStr, "%s infra %d", rwl_client_path, setmode->mode);
		exec_process(gCmdStr);
		sprintf(gCmdStr, "%s join %s", rwl_client_path, setmode->ssid);
		exec_process(gCmdStr);
	}
	bso->wsec = (!setmode->encpType) ? 0 : 1;
	asd_sleep(3);
	sprintf(gCmdStr, "%s wsec %d", rwl_client_path, bso->wsec);
	exec_process(gCmdStr);

	if(setmode->encpType == ENCRYPT_WEP) {
		for (i = 0; i < 4; i++) {
			if (setmode->keys[i][0] != '\0') {
				strcpy(bso->keys[i], setmode->keys[i]);
				sprintf(gCmdStr, "%s addwep  %d %s", rwl_client_path, i, setmode->keys[i]);
				exec_process(gCmdStr);
			}
			else {
				memset(bso->keys[i],0, BCM_WEP_KEY_SIZE_MAX);
			}
		}
		/* set active key */
		if ((setmode->activeKeyIdx > 0) && (setmode->activeKeyIdx < 5)) {
			/* move the index range from (1 to 4) to (0 to 3) */
			bso->primary_key = setmode->activeKeyIdx - 1;
			sprintf(gCmdStr, "%s primary_key %d", rwl_client_path, bso->primary_key);
			exec_process(gCmdStr);
		}
	}
exit:

	SetModeResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_MODE_RESP_TLV, 4, (BYTE *)SetModeResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;

	return TRUE;
}

/* Start: Added BCM functions as per BRCM 1.3 ASD */
int bcmSsidIsGood(char *ssidStr)
{
	int ssidLen = strlen(ssidStr);

	if ((ssidLen == 0) || (ssidLen > BCM_SSID_LEN_MAX)) {
		return (FALSE);
	} else {
		return (TRUE);
	}
}

bcmSsidObj_t *bcmWfaSsidTblFreeEntry()
{
	bcmSsidObj_t *bso;
	int idx;

	DPRINT_INFO(WFA_OUT, "bcmWfaSsidTblFreeEntry\n");

	for (idx = 0; idx < BCM_SSID_MAX; idx++) {
		bso = &bsotbl.ssidObj[idx];
		if (bcmSsidIsGood(bso->ssidStr) == FALSE) {
			return bso;
		}
	}

	DPRINT_ERR(WFA_OUT, "bcmWfaSsidTblFreeEntry: no free entry available.\n");
	return (NULL);
}

bcmSsidObj_t *bcmWfaSsidTblSsidFind(char *ssidStr)
{
	bcmSsidObj_t *bso;
	bcmSsidObj_t *bsoFound= NULL;
	int idx;

	if (bcmSsidIsGood(ssidStr) == FALSE) {
		return (NULL);
	}

	for (idx = 0; idx < BCM_SSID_MAX; idx++) {
		bso = &bsotbl.ssidObj[idx];
		if (bcmSsidIsGood(ssidStr) == FALSE) {
			continue;
		}

		if (strcmp(ssidStr, bso->ssidStr)) {
			continue;
		} else {
			bsoFound = bso;
			break;
		}
	}

	return (bsoFound);
}

bcmSsidObj_t *bcmWfaSsidObjTblAdd(char *ssidStr)
{
	bcmSsidObj_t *bso;

	DPRINT_INFO(WFA_OUT, "bcmWfaSsidObjTblAdd: ssidStr %s\n", ssidStr);

	if (bcmSsidIsGood(ssidStr) == FALSE) {
		return (NULL);
	}

	if ((bso = bcmWfaSsidTblSsidFind(ssidStr))) {
		DPRINT_ERR(WFA_OUT, "bcmWfaSsidObjTblAdd(%s): ssid already exists\n", ssidStr);
		return (bso);
	}

	if (!(bso = bcmWfaSsidTblFreeEntry())) {
		DPRINT_INFO(WFA_OUT, "no free entry\n");
		return (NULL);
	}

	strcpy(bso->ssidStr, ssidStr);
	bso->bssType = BCM_BSS_INFRA; /* init it to infrastructure bss */
	bso->primary_key = BCM_PRI_KEY_BAD; /* init it to bad one */

	bsotbl.addCnt++;
	bsotbl.entries++;

	return (bso);
}

void bcmWfaSsidObjTblDel(char *ssidStr)
{
	bcmSsidObj_t *bso;

	DPRINT_INFO(WFA_OUT, "bcmWfaSsidObjTblDel: ssidStr %s\n", ssidStr);

	bso = bcmWfaSsidTblSsidFind(ssidStr);
	if (bso == NULL) {
		return;
	}

	DPRINT_INFO(WFA_OUT, "bcmWfaSsidObjTblDel: deleting bso %p\n", bso);
	memset(bso,0, sizeof(bcmSsidObj_t));
	bsotbl.delCnt++;
	bsotbl.entries--;
}

void bcmWfaSsidObjPrint(bcmSsidObj_t *bso)
{
	int idx;

	if (bcmSsidIsGood(bso->ssidStr) == FALSE) {
		fprintf(WFA_OUT, "bso %p is blank.\n", bso);
		return;
	}

	fprintf(WFA_OUT, "bso %p\n", bso);
	fprintf(WFA_OUT, "\tssid %s", bso->ssidStr);
	fprintf(WFA_OUT, "\tbssType %d\n", bso->bssType);
	fprintf(WFA_OUT, "\tchannel %d\n", bso->channel);
	fprintf(WFA_OUT, "\twsec %d\n", bso->wsec);
	fprintf(WFA_OUT, "\tauth %d\n", bso->auth);
	fprintf(WFA_OUT, "\twpa_auth %d\n", bso->wpa_auth);
	fprintf(WFA_OUT, "\tpowerSave %d\n", bso->powerSave);
	fprintf(WFA_OUT, "\tuapsd %d\n", bso->uapsd);

	for (idx = 0; idx < 4; idx++) {
		fprintf(WFA_OUT, "\tkeys[%d] : %s\n", idx, bso->keys[idx]);
	}
	fprintf(WFA_OUT, "\tprimary_key %d\n", bso->primary_key);
	fprintf(WFA_OUT, "\tpassphrase : %s\n", bso->passphrase);
}

void bcmWfaSsidObjTblPrint(void)
{
	int idx;

	fprintf(WFA_OUT, "entries %d addCnt %d delCnt %d\n",
		bsotbl.entries, bsotbl.addCnt, bsotbl.delCnt);
	for (idx = 0; idx < BCM_SSID_MAX; idx++) {
		bcmWfaSsidObjPrint(&bsotbl.ssidObj[idx]);
	}
}

/*Do the initialisation for the driver */
void bcmWfaInit(void)
{
	memset(&bsotbl,0, sizeof(bsotbl));

	sprintf(gCmdStr, "%s ap 0", rwl_client_path); /* not AP */
	exec_process(gCmdStr);

	sprintf(gCmdStr, "%s radio on", rwl_client_path); /* not AP */
	exec_process(gCmdStr);

	sprintf(gCmdStr, "%s wsec 0", rwl_client_path);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "%s auth 0", rwl_client_path);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "%s wpa_auth 0", rwl_client_path);
	exec_process(gCmdStr);

	sprintf(gCmdStr, "%s sup_wpa 1", rwl_client_path); /* enable in-driver supplicant */
	exec_process(gCmdStr);

	/* Driver should not be made up explicitly  
	 * as we need to execute uapsd command in the beginning. 
	 */
}
