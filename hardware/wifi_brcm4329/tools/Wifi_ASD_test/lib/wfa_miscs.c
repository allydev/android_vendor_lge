 
/****************************************************************************
 *  (c) Copyright 2007 Wi-Fi Alliance.  All Rights Reserved
 *
 *
 *  LICENSE
 *
 *  License is granted only to Wi-Fi Alliance members and designated
 *  contractors (.$B!H.(BAuthorized Licensees.$B!I.(B)...A.N  Authorized Licensees are granted
 *  the non-exclusive, worldwide, limited right to use, copy, import, export
 *  and distribute this software:
 *  (i) solely for noncommercial applications and solely for testing Wi-Fi
 *  equipment; and
 *  (ii) solely for the purpose of embedding the software into Authorized
 *  Licensee.$B!G.(Bs proprietary equipment and software products for distribution to
 *  its customers under a license with at least the same restrictions as
 *  contained in this License, including, without limitation, the disclaimer of
 *  warranty and limitation of liability, below...A.N  The distribution rights
 *  granted in clause
 *  (ii), above, include distribution to third party companies who will
 *  redistribute the Authorized Licensee.$B!G.(Bs product to their customers with or
 *  without such third party.$B!G.(Bs private label. Other than expressly granted
 *  herein, this License is not transferable or sublicensable, and it does not
 *  extend to and may not be used with non-Wi-Fi applications...A.N  Wi-Fi Alliance
 *  reserves all rights not expressly granted herein...A.N 
 *..A.N 
 *  Except as specifically set forth above, commercial derivative works of
 *  this software or applications that use the Wi-Fi scripts generated by this
 *  software are NOT AUTHORIZED without specific prior written permission from
 *  Wi-Fi Alliance.
 *..A.N 
 *  Non-Commercial derivative works of this software for internal use are
 *  authorized and are limited by the same restrictions; provided, however,
 *  that the Authorized Licensee shall provide Wi-Fi Alliance with a copy of
 *  such derivative works under a perpetual, payment-free license to use,
 *  modify, and distribute such derivative works for purposes of testing Wi-Fi
 *  equipment.
 *..A.N 
 *  Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
 *  or promote products that are derived from or that use this software without
 *  specific prior written permission from Wi-Fi Alliance.
 *
 *  THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A..A.N PARTICULAR PURPOSE,
 *  ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 *  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF
 *  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ******************************************************************************
 */

/*
 * File: wfa_miscs.c - misc functions for agents.
 * 
 *       Revision History:
 *          2006/03/10 -- initially created by qhu
 *          2006/06/01 -- BETA release by qhu
 *          2006/06/13 -- 00.02 release by qhu
 *          2006/06/30 -- 00.10 Release by qhu
 *          2006/07/10 -- 01.00 Release by qhu
 *          2006/09/01 -- 01.05 Release by qhu
 *          2007/01/11 -- 01.10 Released by qhu
 *          2007/02/15  -- WMM Extension Beta released by qhu, mkaroshi
 *          2007/03/30 -- 01.40 WPA2 and Official WMM Beta Release by qhu
 *          2007/04/20 -- 02.00 WPA2 and Official WMM Release by qhu
 *          2007/08/15 --  02.10 WMM-Power Save release by qhu
 *          2007/10/10 --  02.20 Voice SOHO beta -- qhu
 *          2007/11/07 --  02.30 Voice HSO -- qhu
 *
 */
#ifdef WIN32
#include <Winsock2.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#else
#include <arpa/inet.h>
#include <strings.h>
#include <sys/socket.h>
#include <unistd.h>
#include <linux/if.h>
#include <sys/ioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#endif

#include "wfa_debug.h"
#include "wfa_main.h"
#include "wfa_types.h"
#include "wfa_tg.h"
#include "wfa_miscs.h"
#include "wfa_cmds.h"

extern unsigned short wfa_defined_debug;
extern tgStream_t *theStreams;
extern char PingStr[];
tgStream_t *findStreamProfile(int id);
#ifdef WIN32
HANDLE processHandle = NULL;
HANDLE processThread = NULL; 
static unsigned char charmap[] = {
	 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
	 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
	 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
	 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
	 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
	 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
	 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
	 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
	 0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
	 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
	 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
	 0x78, 0x79, 0x7a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
	 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
	 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
	 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
	 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
	 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
	 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
	 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
	 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
	 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
	 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
	 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
	 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
	 0xc0, 0xe1, 0xe2, 0xe3, 0xe4, 0xc5, 0xe6, 0xe7,
	 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
	 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
	 0xf8, 0xf9, 0xfa, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
	 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
	 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
	 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
	 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,
};
#endif
/*
 * printProfile(): a debugging function to display a profile info based on
 *                 a streamId
 */

void printProfile(tgProfile_t *pf)
{
	DPRINT_INFO(WFA_OUT, "profile type %i direction %i Dest ipAddr %s Dest port %i So ipAddr %s So port %i rate %i duration %i pksize %i\n", pf->profile, pf->direction, pf->dipaddr, pf->dport, pf->sipaddr, pf->sport, pf->rate, pf->duration, pf->pksize);
}

void asd_sleep(int SleepTime)
{
#ifndef WIN32
	sleep(SleepTime);
#else
	Sleep(SleepTime * 1000);
#endif
}

void asd_closeSocket(int sockfd)
{
#ifndef WIN32
	close(sockfd);
#else
	closesocket(sockfd);
#endif
}
void asd_shutDown(int Sockfd)
{
#ifndef WIN32
	shutdown(Sockfd, SHUT_WR);
#else
	shutdown(Sockfd, SD_SEND);
#endif
}


void exec_process(char* command)
{
	char wl_cmd[WFA_BUFF_128];
	strcpy(wl_cmd,command);
	DPRINT_INFO(WFA_OUT,"%s\n",wl_cmd);
#ifndef WIN32
	system(wl_cmd);
#else
	asd_Config(wl_cmd," ");
#endif
}

int isString(char *str)
{
	if(*str == '\0')
		return FALSE;

	if((str[0] >= 'a' && str[0] <= 'z') 
		|| (str[0] > 'A' && str[0] < 'Z'))
		return TRUE;
	else
		return FALSE;
}

int isNumber(char *str)
{
	if(*str == '\0')
		return FALSE;

	if (str[0] >= '0' && str[0] <= '9')
		return TRUE;
	else
		return FALSE;
}

int isIpV4Addr(char *str)
{
	int dots = 0;
	char *tmpstr = str;

	if(*str == '\0')
		return FALSE;

	while(*tmpstr != '\0')
	{
		if(*tmpstr == '.')
		{
			dots++;
		}

		tmpstr++;
	}

	if(dots <3)
		return FALSE;
	else
		return TRUE;
}

#ifdef WIN32
char * strtok_r(char *s1, const char *s2, char **lasts)
{
	char *ret;

	if (s1 == NULL)
		s1 = *lasts;

	while(*s1 && strchr(s2, *s1))
		++s1;

	if(*s1 == '\0')
		return NULL;

	ret = s1;

	while(*s1 && !strchr(s2, *s1))
		++s1;

	if(*s1)
		*s1++ = '\0';

	*lasts = s1;

	return ret;
} 


int strcasecmp(const char *s1, const char *s2)
{
	const unsigned char *us1 = (const unsigned char *)s1;
	const unsigned char *us2 = (const unsigned char *)s2;

	while (tolower(*us1) == tolower(*us2)) {
		if (*us1++ == '\0')
			return (0);
		us2++;
	}
	return (tolower(*us1) - tolower(*us2));
}

int strncasecmp(const char *s1,const char *s2, unsigned int length)
{
	unsigned char u1, u2;

	for (; length != 0; length--, s1++, s2++) {
		u1 = (unsigned char) *s1;
		u2 = (unsigned char) *s2;

		if (charmap[u1] != charmap[u2]) {
			return charmap[u1] - charmap[u2];
		}
		if (u1 == '\0') {
			return 0;
		}
	}
	return 0;
}

__inline int wmemcmp(const wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {for (; 0 < _N; ++_S1, ++_S2, --_N)
                if (*_S1 != *_S2)
                        return (*_S1 < *_S2 ? -1 : +1);
        return (0); }
__inline wchar_t *wmemcpy(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {wchar_t *_Su1 = _S1;
        for (; 0 < _N; ++_Su1, ++_S2, --_N)
                *_Su1 = *_S2;
        return (_S1); }
__inline wchar_t *wmemmove(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {wchar_t *_Su1 = _S1;
        if (_S2 < _Su1 && _Su1 < _S2 + _N)
                for (_Su1 += _N, _S2 += _N; 0 < _N; --_N)
                        *--_Su1 = *--_S2;
        else
                for (; 0 < _N; --_N)
                        *_Su1++ = *_S2++;
        return (_S1); }
__inline wchar_t *wmemset(wchar_t *_S, wchar_t _C, size_t _N)
        {wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
                *_Su = _C;
        return (_S); }



DWORD asd_Config(char *strFunct, char *strstrParams)
{
	PROCESS_INFORMATION ProcessInfo;
	char Args[WFA_BUFF_256];
	wchar_t wc_Args[WFA_BUFF_256];
	wchar_t *pDefaultCMD = L"CMD.EXE";
	ULONG rc;

	Args[0]= 0;
	wmemset(wc_Args, 0, WFA_BUFF_256);
	/* "/c" option - Do the command then terminate the command window */
	sprintf(Args, "/C %s %s", (const char *)strFunct, (const char *)strstrParams);
	mbstowcs(wc_Args, Args, strlen(Args));

	if(!CreateProcess(pDefaultCMD,wc_Args, NULL,NULL,FALSE, CREATE_NEW_CONSOLE, NULL,NULL,NULL,&ProcessInfo))
	{
		processHandle = ProcessInfo.hProcess;
		processThread = ProcessInfo.hThread; 
		return GetLastError();		
	}

	WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
	if(!GetExitCodeProcess(ProcessInfo.hProcess, &rc))
		rc = 0;

	CloseHandle(ProcessInfo.hThread);
	CloseHandle(ProcessInfo.hProcess);

	return rc;
}

int GetStats(FILE* pFile, const wchar_t* lpszSearchString , unsigned int *pos, const char* delim) 
{ 

	unsigned long ulFileSize, ulBufferSize; 
	wchar_t lpBuffer[WFA_BUFF_512];
	char mbsbuffer[WFA_BUFF_512],  str[WFA_BUFF_128];
	unsigned int *ulCurrentPosition;
	int retval;

	ulCurrentPosition = pos;

	//make sure we were passed a valid, if it isn't return -1 
	if ((!pFile)||(!lpszSearchString)) { 
		return -1; 
	} 

	//get the size of the file 
	fseek(pFile,0,SEEK_END); 

	ulFileSize=ftell(pFile); 

	fseek(pFile,0,SEEK_SET); 

	//if the file is empty return -1 
	if (!ulFileSize) { 
		return -1; 
	} 

	//get the length of the string we're looking for, this is 
	//the size the buffer will need to be 
	ulBufferSize=wcslen(lpszSearchString); 

	if (ulBufferSize>ulFileSize) { 
		return -1; 
	} 

	*ulCurrentPosition=0; 

	//this is where the actual searching will happen, what happens 
	//here is we set the file pointer to the current position 
	//is incrimented by one each pass, then we read the size of 
	//the buffer into the buffer and compare it with the string 
	//we're searching for, if the string is found we return the 
	//position at which it is found 
	while (*ulCurrentPosition<ulFileSize-ulBufferSize) { 
		fseek(pFile,*ulCurrentPosition,SEEK_SET); 
		wmemset(lpBuffer, 0, WFA_BUFF_512);
		//read ulBufferSize bytes from the file 
		fread(mbsbuffer,1,ulBufferSize,pFile); 

		retval = mbstowcs(lpBuffer, mbsbuffer, strlen(mbsbuffer)); 

		//if the data read matches the string we're looking for 
		if (!wmemcmp(lpBuffer,lpszSearchString,ulBufferSize)) 
		{ 
			fread(str,1,ulBufferSize,pFile);
			strtok(str, delim);
			*ulCurrentPosition = atoi(str);

			//return the position the string was found at 
			return *ulCurrentPosition; 
		} 
		++*ulCurrentPosition; 
	} 
	return -1;
} 

int GetPingStat(FILE* pFile, const wchar_t* lpszSearchString , unsigned int *recv,unsigned int *sent, const char* delim) 
{ 
	unsigned long ulFileSize, ulBufferSize; 
	wchar_t lpBuffer[WFA_BUFF_512];
	char mbsbuffer[WFA_BUFF_512], str[WFA_BUFF_128];
	unsigned int *ulCurrentPosition, *ulReceived, *ulsent;
	int retval;

	ulCurrentPosition=recv;
	ulReceived= recv;
	ulsent = sent; 

	//make sure we were passed a valid, if it isn't return -1 
	if ((!pFile)||(!lpszSearchString)) { 
		return -1; 
	} 

	//get the size of the file 
	fseek(pFile,0,SEEK_END); 

	ulFileSize=ftell(pFile); 

	fseek(pFile,0,SEEK_SET); 

	//if the file is empty return -1 
	if (!ulFileSize) { 
		return -1; 
	} 

	//get the length of the string we're looking for, this is 
	//the size the buffer will need to be 
	ulBufferSize=wcslen(lpszSearchString); 

	if (ulBufferSize>ulFileSize) { 
		return -1; 
	} 

	*ulCurrentPosition=0; 

	//this is where the actual searching will happen, what happens 
	//here is we set the file pointer to the current position 
	//is incrimented by one each pass, then we read the size of 
	//the buffer into the buffer and compare it with the string 
	//we're searching for, if the string is found we return the 
	//position at which it is found 
	while (*ulCurrentPosition<ulFileSize-ulBufferSize) { 
		fseek(pFile,*ulCurrentPosition,SEEK_SET); 
		wmemset(lpBuffer, 0, WFA_BUFF_512);
		//read ulBufferSize bytes from the file 
		fread(mbsbuffer,1,ulBufferSize,pFile); 

		retval = mbstowcs(lpBuffer, mbsbuffer, strlen(mbsbuffer)); 

		//if the data read matches the string we're looking for 
		if (!wmemcmp(lpBuffer,lpszSearchString,ulBufferSize)) { 
			fread(str,1,22,pFile);
			// strtok(str, delim);
			*ulReceived = atoi(str);
			strtok(str, (const char*)ulReceived);
			//fread(str,1,ulBufferSize,pFile);
			//strtok(str, delim);
			*ulsent= atoi(str);
			//return the position the string was found at 
			return *ulCurrentPosition; 
		} 

		++*ulCurrentPosition; 
	} 
	return -1;
} 

int FileSearch(FILE* pFile, const wchar_t* lpszSearchString , unsigned int *pos) 
{ 
	unsigned long ulFileSize, ulBufferSize;
	wchar_t lpBuffer[WFA_BUFF_512];
	char mbsbuffer[WFA_BUFF_512];
	unsigned long *ulCurrentPosition;
	int retval;

	ulCurrentPosition= pos;
	//make sure we were passed a valid, if it isn't return -1 
	if ((!pFile)||(!lpszSearchString)) { 
		return -1; 
	} 

	//get the size of the file 
	fseek(pFile,0,SEEK_END); 

	ulFileSize=ftell(pFile); 

	fseek(pFile,0,SEEK_SET); 

	//if the file is empty return -1 
	if (!ulFileSize) { 
		return -1; 
	} 

	//get the length of the string we're looking for, this is 
	//the size the buffer will need to be 
	ulBufferSize=wcslen(lpszSearchString); 

	if (ulBufferSize > ulFileSize) { 
		return -1; 
	} 

	*ulCurrentPosition=0; 

	//this is where the actual searching will happen, what happens 
	//here is we set the file pointer to the current position 
	//is incrimented by one each pass, then we read the size of 
	//the buffer into the buffer and compare it with the string 
	//we're searching for, if the string is found we return the 
	//position at which it is found 
	while (*ulCurrentPosition<ulFileSize-ulBufferSize) { 
		fseek(pFile,*ulCurrentPosition,SEEK_SET); 
		wmemset(lpBuffer, 0, WFA_BUFF_512);
		//read ulBufferSize bytes from the file 
		fread(mbsbuffer,1,ulBufferSize,pFile); 

		retval = mbstowcs(lpBuffer, mbsbuffer, strlen(mbsbuffer)); 

		//if the data read matches the string we're looking for 
		if (!wmemcmp(lpBuffer,lpszSearchString,ulBufferSize)) 
		{ 
			//return the position the string was found at 
			return *ulCurrentPosition; 
		} 

		//incriment the current position by one 
		++*ulCurrentPosition; 
	} 
	return -1;
} 

unsigned int uGetLocalIP()
{
	char szHostName[WFA_BUFF_256];
	struct hostent*	HostData;

	GetHostName(szHostName, WFA_BUFF_256);
	HostData = gethostbyname(szHostName);
	if (HostData == NULL)
		return 0;

	return *((unsigned int*)HostData->h_addr);
}

char* GetHostName(char* buf, int len) 
{
	if (gethostname(buf, len) == SOCKET_ERROR)
		return NULL;
	return buf;
}

int wfa_Winitime_diff(SYSTEMTIME *t1, SYSTEMTIME *t2)
{
	int dtime;
	int sec = t2->wSecond - t1->wSecond;
	int msec = (t2->wMilliseconds - t1->wMilliseconds);

	if(msec < 0)
	{
		sec -=1;
		msec += 1000;
	}

	dtime = sec*1000 + msec;
	return dtime;
}

int wfa_Win_estimate_timer_latency()
{
	SYSTEMTIME t1, t2, tp2;
#ifndef WIN32
	int sleep=20000; /* two miniseconds */
#else 
	int sleep =2;
#endif
	int latency =0;

	GetSystemTime(&t1);
	usleep(sleep);

	GetSystemTime(&t2); 

	tp2.wMilliseconds = t1.wMilliseconds  +20;
	if( tp2.wMilliseconds >= 1000) {
		tp2.wSecond = t1.wSecond +1;
		tp2.wMilliseconds -= 1000;
	}
	else
		tp2.wSecond = t1.wSecond;

	return latency = (t2.wSecond - tp2.wSecond)  + (t2.wMilliseconds - tp2.wMilliseconds); 
}

/*This code is taken  from the NETUI application sample that is provided in the WinCE Source.
 * The source code is present in $(WINCEROOT)\PUBLIC\COMMON\OAK\DRIVERS\NETSAMP 
 * In this function we look for the registry entry of the Wireless interface and then add the 
 * IP properties like IP address, mask etc. After adding the IP address the we need to restart the NDIS
 * driver for the changes to take effect.
 */
BOOL IPProperties(caStaSetIpConfig_t *NewipConfig, DWORD* Index)
{
	TCHAR       multiSz[257];
	DWORD       cbBuffer = sizeof(multiSz);
	BOOL	fRetVal = FALSE;
	TCHAR	szTemp[256];
	HKEY	hKey;
	LONG	hRes;
	DWORD	dwDisp, dwSize;
	NETWORK_ADPT_INFO	AdptInfo;
	DWORD	Len;
	TCHAR szAdapterName[WFA_BUFF_512];

	if (NewipConfig->intf == NULL)
		return FALSE;

	/* Initialize the adapter Info. */
	memset((char *)&AdptInfo, 0, sizeof(AdptInfo));
	wmemset(szAdapterName, 0, WFA_BUFF_512);
	mbstowcs(szAdapterName, NewipConfig->intf, strlen(NewipConfig->intf));

	AdptInfo.szAdapterName = szAdapterName;
	AdptInfo.IPAddr = inet_addr(NewipConfig->ipaddr);
	AdptInfo.fUseDHCP = NewipConfig->isDhcp;
	AdptInfo.Gateway = inet_addr(NewipConfig->defGateway);
	AdptInfo.SubnetMask = inet_addr(NewipConfig->mask);
	if (NewipConfig->pri_dns) {
		AdptInfo.DNSAddr = inet_addr(NewipConfig->pri_dns);
		AdptInfo.DNSAltAddr = inet_addr(NewipConfig->sec_dns);
	}

	/* Get the current registry data. */
	_tcscpy(szTemp, TEXT("Comm\\"));
	_tcscat(szTemp, szAdapterName);
	hKey = NULL;
	hRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTemp, 0, KEY_ALL_ACCESS, &hKey);
	if (ERROR_SUCCESS == hRes) {
		AdptInfo.szDisplayName[0] = TEXT('\0');
		dwSize = sizeof(AdptInfo.szDisplayName);
		RegQueryValueEx(hKey, TEXT("DisplayName"), NULL,
			NULL, (LPBYTE)AdptInfo.szDisplayName, &dwSize);
		RegCloseKey(hKey);
	}

	if (hKey == NULL)
	{
		/* Create it. */
		hRes = RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("Comm\\BCMSDDHD1\\Parms\\TcpIp"), 0,
			NULL, REG_OPTION_NON_VOLATILE, 0, NULL, &hKey, &dwDisp);
		if (hRes != ERROR_SUCCESS) {
			DPRINT_INFO(WFA_OUT, "!Unable to create reg key '%s'\r\n", szTemp);
		}
	}
	/* Just in case the create failed. */
	if (hKey != NULL)
	{
		fRetVal = TRUE;
		/* I'd like 1 to mean TRUE. */
		if (AdptInfo.fUseDHCP) {
			AdptInfo.fUseDHCP = 1;
		}

		hRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			TEXT("Comm\\BCMSDDHD1\\Parms\\TcpIp"), 0, KEY_SET_VALUE, &hKey);
		if (hRes != ERROR_SUCCESS) {
			DPRINT_INFO(WFA_OUT, "!Unable to open 1\n");
		}
		hRes = RegSetValueEx(hKey, TEXT("EnableDHCP"), 0,
			REG_DWORD, (char *)&(AdptInfo.fUseDHCP), sizeof(DWORD));
		if (hRes != ERROR_SUCCESS) {
			DPRINT_INFO(WFA_OUT, "!Unable to set EnableDHCP\n");
		}
		RegCloseKey(hKey);
		IPAddrToStr(szTemp, AdptInfo.IPAddr);
		Len = _tcslen(szTemp)+1;
		szTemp[Len++] = TEXT('\0');


		hRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			TEXT("Comm\\BCMSDDHD1\\Parms\\TcpIp"), 0, KEY_SET_VALUE, &hKey);
		if (hRes != ERROR_SUCCESS) {
			DPRINT_INFO(WFA_OUT, "!Unable to open 2\n");
		}
		hRes = RegSetValueEx(hKey, TEXT("IpAddress"), 0,
			REG_MULTI_SZ, (char *)szTemp, sizeof(TCHAR)*Len);
		if (hRes != ERROR_SUCCESS) {
			DPRINT_INFO(WFA_OUT, "!Unable to set IpAddress\n");
		}
		RegCloseKey(hKey);


		IPAddrToStr(szTemp, AdptInfo.SubnetMask);
		Len = _tcslen(szTemp)+1;
		szTemp[Len++] = TEXT('\0');
		hRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			TEXT("Comm\\BCMSDDHD1\\Parms\\TcpIp"), 0, KEY_SET_VALUE, &hKey);
		if (hRes != ERROR_SUCCESS) {
			DPRINT_INFO(WFA_OUT, "!Unable to open 3\n");
		}
		RegSetValueEx(hKey, TEXT("SubnetMask"), 0, REG_MULTI_SZ,
			(char *)szTemp, sizeof(TCHAR)*Len);
		if (hRes != ERROR_SUCCESS) {
			DPRINT_INFO(WFA_OUT, "!Unable to set SubnetMask\n");
		}
		RegCloseKey(hKey);

		IPAddrToStr(szTemp, AdptInfo.Gateway);
		Len = _tcslen(szTemp)+1;
		szTemp[Len++] = TEXT('\0');
		hRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			TEXT("Comm\\BCMSDDHD1\\Parms\\TcpIp"), 0, KEY_SET_VALUE, &hKey);
		RegSetValueEx(hKey, TEXT("DefaultGateway"), 0,
			REG_MULTI_SZ, (char *)szTemp, sizeof(TCHAR)*Len);
		RegCloseKey(hKey);

		Len = 0;
		if (AdptInfo.DNSAddr) {
			IPAddrToStr(szTemp, AdptInfo.DNSAddr);
			Len = _tcslen(szTemp)+1;
			if (AdptInfo.DNSAltAddr) {
				IPAddrToStr(szTemp+Len, AdptInfo.DNSAltAddr);
				Len += _tcslen(szTemp+Len)+1;
				/* allow for NULL character added by IPAddrToStr */
			}
			szTemp[Len++] = TEXT('\0');
		} else if (AdptInfo.DNSAltAddr) {
			IPAddrToStr(szTemp, AdptInfo.DNSAltAddr);
			Len = _tcslen(szTemp)+1;
			szTemp[Len++] = TEXT('\0');
		}
		hRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			TEXT("Comm\\BCMSDDHD1\\Parms\\TcpIp"), 0, KEY_SET_VALUE, &hKey);
		if (Len) {
			RegSetValueEx(hKey, TEXT("DNS"), 0,
				REG_MULTI_SZ, (char *)szTemp, sizeof(TCHAR)*Len);
		} else {
			RegSetValueEx(hKey, TEXT("DNS"), 0,
				REG_MULTI_SZ, (char *)TEXT(""), sizeof(TCHAR));
		}
		RegCloseKey(hKey);

		Len = 0;
		if (AdptInfo.WINSAddr) {
			IPAddrToStr(szTemp, AdptInfo.WINSAddr);
			Len = _tcslen(szTemp)+1;
			if (AdptInfo.WINSAltAddr) {
				IPAddrToStr(szTemp+Len, AdptInfo.WINSAltAddr);
				Len += _tcslen(szTemp+Len)+1;
				/* allow for NULL character added by IPAddrToStr */
			}
			szTemp[Len++] = TEXT('\0');
		} else if (AdptInfo.WINSAltAddr) {
			IPAddrToStr(szTemp, AdptInfo.WINSAltAddr);
			Len = _tcslen(szTemp)+1;
			szTemp[Len++] = TEXT('\0');
		}
		hRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			TEXT("Comm\\BCMSDDHD1\\Parms\\TcpIp"), 0, KEY_SET_VALUE, &hKey);
		if (Len) {
			RegSetValueEx(hKey, TEXT("WINS"), 0,
				REG_MULTI_SZ, (char *)szTemp, sizeof(TCHAR)*Len);
		} else {
			RegSetValueEx(hKey, TEXT("WINS"), 0,
				REG_MULTI_SZ, (char *)TEXT(""), sizeof(TCHAR));
		}
		RegCloseKey(hKey);
	}

	if (hKey) {
		/* Flush the Registry to take effect */
		RegFlushKey(hKey);
		RegCloseKey(hKey);
	}

	/* because we building a szTemp we need to leave room for the */
	/* double null at the end so copy one less than the buffer. */

	StringCchCopy(szTemp, (sizeof(szTemp) / sizeof(TCHAR))-1, szAdapterName);
	szTemp[_tcslen(szTemp)+1] = _T('\0'); /* szTemp needs an extra null */

	DoNdisIOControl(IOCTL_NDIS_UNBIND_ADAPTER, szTemp,
		(_tcslen(szTemp)+2) * sizeof(TCHAR), NULL, NULL);

	DoNdisIOControl(IOCTL_NDIS_BIND_ADAPTER, szTemp,
		(_tcslen(szTemp)+2) * sizeof(TCHAR), NULL, NULL);

	return fRetVal;
}

/* In this function we change the properties of the adapter from Static IP to DHCP */
void ResetIP(caStaSetIpConfig_t *TempipConfig) 
{
	TCHAR	szTemp[WFA_BUFF_256];
	HKEY	hKey;
	LONG	hRes;
	TCHAR szAdapterName[WFA_BUFF_512];

	NETWORK_ADPT_INFO	AdptInfo;

	hKey = NULL;

	memset((char *)&AdptInfo, 0, sizeof(AdptInfo));
	wmemset(szAdapterName, 0, WFA_BUFF_512);
	mbstowcs(szAdapterName, TempipConfig->intf, strlen(TempipConfig->intf));

	AdptInfo.szAdapterName = szAdapterName;
	AdptInfo.fUseDHCP = TempipConfig->isDhcp;


	hRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Comm\\BCMSDDHD1\\Parms\\TcpIp"),
		0, KEY_SET_VALUE, &hKey);
	if (hRes != ERROR_SUCCESS) {
		DPRINT_INFO(WFA_OUT, "!Unable to open EnableDHCP\n");
	}
	hRes = RegSetValueEx(hKey, TEXT("EnableDHCP"), 0, REG_DWORD,
		(char *)&(AdptInfo.fUseDHCP), sizeof(DWORD));
	if (hRes != ERROR_SUCCESS) {
		DPRINT_INFO(WFA_OUT, "!Unable to set EnableDHCP\n");
	}
	RegCloseKey(hKey);


	StringCchCopy(szTemp, (sizeof(szTemp) / sizeof(TCHAR))-1, szAdapterName);
	szTemp[_tcslen(szTemp)+1] = _T('\0'); /* szTemp needs an extra null */

	DoNdisIOControl(IOCTL_NDIS_REBIND_ADAPTER, szTemp,
		(_tcslen(szTemp)+2) * sizeof(TCHAR), NULL, NULL);

}

VOID
GetMultiSZAddr (HKEY hKey, LPTSTR szValueName, LPDWORD pAddr1, LPDWORD pAddr2)
{
	TCHAR	szTemp[WFA_BUFF_256];
	LPTSTR	szPtr;
	LONG	hRes;
	DWORD	dwSize, dwType;

	dwSize = sizeof(szTemp);
	hRes = RegQueryValueEx (hKey, szValueName, 0, &dwType, (LPBYTE)szTemp,
		&dwSize); 
	if ((hRes == ERROR_SUCCESS) &&
		((dwType == REG_SZ) || (dwType == REG_MULTI_SZ))) {
			if (pAddr1 && szTemp[0]) {
				StringToAddr (szTemp, pAddr1);
			}
			if (pAddr2 && szTemp[0] && (dwType == REG_MULTI_SZ)) {
				szPtr = szTemp;
				while (*szPtr) {
					szPtr++;
				}
				// Move past the null.
				szPtr++;
				if (*szPtr) {
					StringToAddr (szPtr, pAddr2);
				}
			}
	} else {
		DPRINT_INFO(WFA_OUT, "GetMultiSZ: '%s' hRes=%d dwType=%d\r\n", szValueName, hRes, dwType);
	}
}


void
IPAddrToStr(LPTSTR szStr, DWORD IPAddr)
{
	/* wsprintf (szStr, TEXT("%d.%d.%d.%d"), (IPAddr >> 24) & 0xFF, */
	/* (IPAddr >> 16) & 0xFF, (IPAddr >> 8) & 0xFF, IPAddr & 0xFF);--Girish */
	wsprintf(szStr, TEXT("%d.%d.%d.%d"), (IPAddr & 0xFF), (IPAddr >> 8) & 0xFF,
		(IPAddr >> 16) & 0xFF, (IPAddr >> 24) & 0xFF);
}

BOOL 
StringToAddr(TCHAR *AddressString, DWORD *AddressValue) {
	TCHAR	*pStr = AddressString;
	PUCHAR	AddressPtr = (PUCHAR)AddressValue;
	int		i;
	int		Value;

	// Parse the four pieces of the address.
	for (i=0; *pStr && (i < 4); i++) {
		Value = 0;
		while (*pStr && TEXT('.') != *pStr) {
			if ((*pStr < TEXT('0')) || (*pStr > TEXT('9'))) {
				DPRINT_INFO(WFA_OUT, "Unable to convert %s to address\r\n", AddressString);
				return FALSE;
			}
			Value *= 10;
			Value += *pStr - TEXT('0');
			pStr++;
		}
		if (Value > 255) {
			DPRINT_INFO(WFA_OUT, "Unable to convert %s to address\r\n",AddressString);
			return FALSE;
		}
		AddressPtr[i] = Value;
		if (TEXT('.') == *pStr) {
			pStr++;
		}
	}

	// Did we get all of the pieces?
	if (i != 4) {
		DPRINT_INFO(WFA_OUT, "Unable to convert %s to address\r\n" ,  AddressString);
		return FALSE;
	}

	*AddressValue = net_long (*AddressValue);

	DPRINT_INFO(WFA_OUT, "Converted %s to address %X\r\n",  AddressString, *AddressValue);

	return TRUE;
}	// StringToAddr()

BOOL DoNdisIOControl(DWORD dwCommand, LPVOID pInBuffer, DWORD cbInBuffer,
	LPVOID pOutBuffer, DWORD * pcbOutBuffer)
{
	HANDLE hNdis;
	BOOL fResult = FALSE;
	int errno;

	hNdis = CreateFile(DD_NDIS_DEVICE_NAME, GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, NULL);

	if (INVALID_HANDLE_VALUE != hNdis) {
		fResult = DeviceIoControl(hNdis, dwCommand, pInBuffer, cbInBuffer,
			pOutBuffer, (pcbOutBuffer?*pcbOutBuffer:0), pcbOutBuffer, NULL);

		if (fResult == 0) {
			errno = GetLastError();
			DPRINT_INFO(WFA_OUT, "DeviceIoControl failed with error no:%d\n", errno);
		}

		CloseHandle(hNdis);
	}

	return fResult;
}

/*This function is used to ping the destination IP address. This runs in a seperate thread. */
DWORD PingStart( )
{
	PROCESS_INFORMATION ProcessInfo;
	char Args[WFA_BUFF_256];
	wchar_t wc_Args[WFA_BUFF_256];
	wchar_t *pDefaultCMD = L"CMD.EXE";

	Args[0]= 0;
	wmemset(wc_Args, 0, WFA_BUFF_256);
	/* "/c" option - Do the command then terminate the command window */
	sprintf(Args, "/c %s >%s", (const char *)PingStr, (const char *)PING_STATUS_FILE_PATH );
	mbstowcs(wc_Args, Args, strlen(Args));

	DPRINT_INFO(WFA_OUT, "Args= %s\n", Args);
	if(!CreateProcess(pDefaultCMD,wc_Args, NULL,NULL,FALSE, CREATE_NEW_CONSOLE, NULL,NULL,NULL,&ProcessInfo))
	{
		processHandle = ProcessInfo.hProcess;
		processThread = ProcessInfo.hThread;  
		DPRINT_INFO(WFA_OUT, "the createprocess error= %d\n", GetLastError());
		return GetLastError();		
	}
	if(!GetExitCodeProcess(ProcessInfo.hProcess, &exitcode))
		exitcode = 0;

	WaitForSingleObject(ProcessInfo.hProcess, INFINITE);

	CloseHandle(ProcessInfo.hThread);
	CloseHandle(ProcessInfo.hProcess);

	return exitcode;
}
#endif /* WIN32 */

inline double wfa_timeval2double(struct timeval *tval)
{
	return ((double) tval->tv_sec + (double) tval->tv_usec*1e-6);
}

inline void wfa_double2timeval(struct timeval *tval, double dval)
{
	tval->tv_sec = (long int) dval;
	tval->tv_usec = (long int) ((dval - tval->tv_sec) * 1000000);
}

inline double wfa_ftime_diff(struct timeval *t1, struct timeval *t2)
{
	double dtime;

	dtime = wfa_timeval2double(t2) - wfa_timeval2double(t1);
	return dtime ;
}

int wfa_itime_diff(struct timeval *t1, struct timeval *t2)
{
	int dtime;
	int sec = t2->tv_sec - t1->tv_sec;
	int usec = t2->tv_usec - t1->tv_usec;

	if(usec < 0)
	{
		sec -=1;
		usec += 1000000;
	}

	dtime = sec*1000000 + usec;
	return dtime;
}


/*
 * THe following two functions are converting Little Endian to Big Endian. 
 * If your machine is already a Big Endian, you may flag it out.
 */
inline void int2BuffBigEndian(int val, char *buf)
{
	char *littleEn = (char *)&val;

	buf[0] = littleEn[3];
	buf[1] = littleEn[2];
	buf[2] = littleEn[1];
	buf[3] = littleEn[0];
}

int bigEndianBuff2Int(char *buff)
{
	int val;
	char *strval = (char *)&val;

	strval[0] = buff[3];
	strval[1] = buff[2];
	strval[2] = buff[1];
	strval[3] = buff[0];

	return val;
}

#ifndef WIN32
int wfa_estimate_timer_latency()
{
	struct timeval t1, t2, tp2;
	int sleep=20000; /* two miniseconds */
	int latency =0;

	gettimeofday(&t1, NULL);
	usleep(sleep);

	gettimeofday(&t2, NULL); 

	tp2.tv_usec = t1.tv_usec + 20000;
	if( tp2.tv_usec >= 1000000)
	{
		tp2.tv_sec = t1.tv_sec +1;
		tp2.tv_usec -= 1000000;
	}
	else
		tp2.tv_sec = t1.tv_sec;

	return latency = (t2.tv_sec - tp2.tv_sec) * 1000000 + (t2.tv_usec - tp2.tv_usec); 
}
#endif

